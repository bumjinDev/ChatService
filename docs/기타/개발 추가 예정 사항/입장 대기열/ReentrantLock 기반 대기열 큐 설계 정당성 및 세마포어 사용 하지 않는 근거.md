# 📘 [ReentrantLock 기반 대기열 큐 설계 정당성 및 세마포어 대체 근거]

## 1. 철학적/구조적 선택 배경

기존 Semaphore는 입장 가능 여부를 카운팅 기반으로 통제하는 구조이며, 이는 permit 수량이라는 정수 값만을 기반으로 한, 비상태적이고 비순차적인 동시성 제어를 전제로 한다. 이 구조는 단일 자원 접근에 대한 제한을 구현하는 데는 간결하고 효과적이지만, 큐 기반 순차 제어, 조건 분기, 세션 기반 상태 관리 등 복합적인 요구가 들어가는 입장 대기 구조에 대해선 구조적 불일치를 야기한다.

특히 대기열 큐를 이용한 설계에서는 단순 입장 실패 → 재시도 순환이 아니라, 세션 ID 기반 식별 → 큐 삽입 → 조건 신호 → 재확인 → 입장 여부 판단이라는 일련의 단계가 필요하며, 이는 단순 count-decrement 방식으로는 처리할 수 없다.

---

## 2. 해결하려는 문제의 본질 해부

**CAS 기반 큐(ConcurrentLinkedQueue)**를 사용할 경우, 큐 자체는 lock-free 구조로 thread-safe하게 동작하지만, 다음과 같은 race condition은 큐 외부 로직에서 여전히 발생할 수 있다:

- 세션이 close되는 순간과 큐 탐색/삭제 사이의 타이밍 충돌  
- 큐 삽입 직후 signal 전파 시점 이전에 상태가 변한 경우의 오동작  
- 대기열 삽입과 제거 작업이 동시에 실행되는 경우의 비원자적 상태 파괴  

따라서 큐의 사용 자체가 thread-safe하다는 점과, 큐를 사용하는 로직 전체의 원자성이 보장된다는 점은 전혀 동일하지 않으며, 이 둘의 불일치는 락 기반 통제 구조로 보완해야 한다.

---

## 3. 내부 구성 요소 선택의 책임 분해

### Semaphore 구조의 한계

- 각 roomId 단위로 Semaphore를 관리하면 큐가 아닌 정수 상태만 추적하게 되며, 실제 어떤 세션이 대기 중인지, 어떤 세션이 끊겼는지 등 상태 기반 제어가 불가능하다.
- `Semaphore.release()`는 특정 대기 중인 스레드를 명시적으로 깨우지 않으며, 내부 wait queue에서 어떤 스레드가 깨어날지는 JVM 수준에 위임되며, 순서를 제어할 수 없다.
- 즉, Semaphore는 "대기열 제어"가 아닌 "자원 수량 제어"에 특화된 구조로, 요구하는 설계 요구사항(세션 기반 대기 제어, 조건 기반 signal 등)과 철학적으로 충돌한다.

### ReentrantLock + Condition 구조의 적합성

- `ReentrantLock`은 명시적 락 획득/해제를 통해 큐 삽입/삭제/탐색 과정 전체를 원자적 단위로 보호할 수 있으며, 큐 외부 로직의 일관성을 보장한다.
- 각 roomId 단위로 Lock + Condition을 구성하면, 방 단위 상태 추적 및 signal을 통한 조건 분기 처리가 가능하며, 구조가 명확하게 분리된다.
- `Condition.await()` 및 `signal()`은 특정 조건이 충족되었을 때만 다음 시도를 유도하는 구조를 만들어, CPU 리소스를 효율적으로 사용하고, 무한 루프 없이 통제 흐름을 구현할 수 있다.

---

## 4. 프레임워크 수준에서의 작동 메커니즘

- 입장 불가 시점:  
    - `JoinService.confirmJoinRoom()` 내에서 Semaphore가 0이면, "WAITING_ROOM" 코드 반환  
    - 클라이언트는 WebSocket 세션을 유지한 채, `/queue/enter` 요청 전송  
    - 서버에서는 `QueueManager.getLock(roomId).lock()` 수행 후, `ConcurrentLinkedQueue`에 세션 삽입  
    - 이후 `await()`로 signal을 수신할 때까지 블로킹 (별도 대기 쓰레드에서 polling 없이 구현 가능)  
    - WebSocket 세션 종료 시, handler가 해당 세션을 큐에서 제거 → `Condition.signal()` 호출  
    - signal을 받은 스레드는 `confirmJoinRoom()` 재확인 후 입장 시도  

---

## 5. 시스템 내 위상 및 유지보수 효과

해당 구조는 대기열이라는 논리적 자원 상태를 명시적으로 모델링하며, 큐 삽입/제거/검사/재시도 로직을 모두 락 기반으로 통제함으로써 큐 자료구조 외부의 비원자적 충돌 가능성을 제거한다. 또한 각 방 ID 별로 독립된 ReentrantLock + Condition 구조를 가지므로, 향후 구조 변경(예: Redis 기반 큐, MQ 기반 signal) 시에도 명확한 단위 책임 분리가 유지되어 구조 이식성이 뛰어나다. 반면 Semaphore는 단일 count 상태만으로 내부 큐를 숨겨 관리하므로, 외부 조건/세션과 연동된 상태 통제를 설계 수준에서 완전히 배제하게 되어, 실무 적용 시 유지보수 불가능한 추상화로 전락할 가능성이 크다.

---

이 설명은 포트폴리오 내 "동시성 제어 구조 선택 근거" 항목으로 독립적으로 문서화 가능하며, 실험 설계 및 실제 테스트 결과와 연결해 비교 항목으로 정리할 수 있다.

추가 요청 시, 위 내용을 기반으로 .md 또는 .txt 문서 형식으로 정제하거나, 코드 측 리팩토링 플랜과 함께 구조도 연동 가능. 필요시 QueueManager, ConditionRegistry, SessionEntry 등 클래스 단위 구조도도 정리 가능.
