# 설계 보장 기반 시나리오 테스트 구조 및 원칙

---

## 1. 테스트 목적

설계 기반 시나리오 테스트의 본질적 목적은 다음과 같다.

- 예외 상황을 의도적으로 발생시키는 것이 아닌,  
  정상 흐름 상의 상태 전이 구조가 설계대로 작동하는지를 구조 단위로 입증하는 것.  
- 테스트의 핵심은 단순한 기능 유무가 아니라,  
  “설계된 상태 전이와 책임 분리 구조가 실제 코드 흐름에서 관측 가능하게 작동하는가”를 증명하는 데 있다.  

이러한 검증은 설계자가 정의한 책임 경로가 코드상에 그대로 반영되고 있으며,  
각 상태가 독립적 단위로 테스트 가능한지 여부를 확인하는 절차이다.

---

## 2. 테스트 흐름의 구간 분리 원칙

흐름을 단순 기능 단위로 나누는 것이 아니라,  
**상태 전이를 유발하는 단일 책임 단위**를 기준으로 구간을 분리한다.  
이 기준은 다음과 같은 설계 구조 원칙을 따른다.

### 2.1 단일 상태 전이 책임자 기준

- 시스템 내 각 흐름은 하나의 트리거 이후 하나의 상태 집합만을 변경한다.  
- 예시:
  - `confirmJoinRoom()` → permit 상태 변경
  - `joinRoom()` → DB 반영
  - `register()` → 세션 등록

이들 각각은 독립된 책임 경로이며, 예외 발생 시 복구 대상이 상이하다.  
따라서 하나의 테스트 시나리오에서 통합 검증할 수 없다.

### 2.2 복구 흐름 및 Assertion 단위 분리

- permit 점유는 TTL에 의해 복구되며,  
- 세션 등록 실패는 재접속을 통해 감지된다.  
- 각 단위마다 복구 방식과 Assertion 기준이 다르므로, 하나의 시나리오로 통합하면 검증 기준이 모호해진다.  
- 테스트는 반드시 “단일 복구 흐름과 단일 Assertion 기준”을 기반으로 구성되어야 한다.

### 2.3 전이 책임 단위 비보장 상태 탐지

- 특정 흐름이 호출되지 않은 상태에서 다음 책임 단위 흐름이 시작되면,  
  설계 보장 구조가 무너진다.  
- 예: `joinRoom()`이 호출되지 않았다면, 그 이후 `register()`는 호출되어선 안 된다.  
- 따라서 테스트는 반드시 각 책임 단위의 시작과 종료 시점을 명시적으로 분리하고 검증해야 한다.

---

## 3. 기능 중심 흐름 분해의 한계

기능 단위 시나리오는 사용자 중심 표현으로는 유효할 수 있지만,  
설계자 중심의 상태 전이 보장 테스트로는 부적합하다.  
그 이유는 다음과 같다.

### 3.1 실패 원인 추적 불가

- 단일 시나리오에 복수 책임 단위가 포함되면, 테스트 실패 시  
  어느 책임 단위에서 실패가 발생했는지 역추적이 불가능하다.

### 3.2 복구 흐름 테스트 미완성

- 하나의 흐름에 복수 상태 전이 지점이 존재할 경우,  
  중간 실패가 발생해도 복구 검증이 수행되지 못한 채 흐름이 중단된다.

### 3.3 Assertion 기준 불명확

- Assertion이 “입장 성공”과 같은 기능 중심 표현에 묶이면,  
  세부적으로 어떤 책임 단위의 상태가 성공했는지를 판별할 수 없다.  
- 이는 설계 일관성 검증으로서의 테스트 목적을 달성하지 못한다.

---

## 4. 테스트 설계 원칙 비교표

| 구분 | 상태 기반 흐름 시나리오 | 기능 단위 통합 시나리오 |
|------|--------------------------|---------------------------|
| 단위 책임 추적 가능성 | ✅ 책임자별 분리 | ❌ 다수 책임 혼재 |
| 실패 원인 진단 가능성 | ✅ 단위 실패 명확화 | ❌ 추적 불가 |
| 복구 흐름 테스트 가능성 | ✅ 단위 복구 검증 | ❌ 실패 시 흐름 종료 |
| Assertion 명확성 | ✅ 각 전이에 명시적 연결 | ❌ 전체 흐름 기준만 존재 |
| 구조 변경 대응성 | ✅ 책임 단위별 수정 가능 | ❌ 전체 재작성 필요 |

---

## 5. 설계 검증 체계의 구조적 목표

이 테스트 체계는 코드가 설계된 상태 흐름대로 실행되는지를 “추론”이 아닌 “증명”으로 확인하는 구조이다.  
이는 테스트가 아닌 구조적 보증 도구로 작동하며, 다음을 목표로 한다:

### 5.1 명세-구현 일치성 보장

- 예:  
  - `SemaphoreRegistry.tryAcquire()`는 실제로 permit 점유가 되었는가  
  - `joinRoom()`은 DB 반영이 완료되었는가  
  - `afterConnectionClosed()`는 permit을 회수했는가

### 5.2 설계 누락 탐지

- 예외 복구 로직이 존재하지 않거나, 상태 회수가 설계에 반영되지 않은 경우를  
  테스트를 통해 식별하는 것이 목적이다.  
- 이는 코드 버그가 아닌 설계 실패이며, 테스트 실패는 이 구조 누락을 드러낸다.

### 5.3 정상 흐름의 음영부 보장

- WebSocket 미연결, `joinRoom()` 예외 등의 시나리오에서  
  **정상 흐름에 숨겨진 복구 설계의 존재 여부**까지 테스트를 통해 입증한다.

---

## 6. 정의적 결론

> 이 시나리오 기반 테스트의 목적은 기능의 성공 여부가 아니라,  
> **설계의 진실성을 구조적으로 증명하고,  
> 상태 흐름 전이의 보장 범위를 코드로부터 추출 가능하게 만드는 것**이다.

이는 단순 테스트가 아니라, **설계 보증 시스템(Design Verification System)**으로 분류된다.

---
