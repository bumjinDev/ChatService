# 📘 2단계: 설계 문서와 책임 단위 매핑 정의 (완전판)

이 문서는 시나리오 테스트 절차 중 2단계에 해당하는 **“설계 문서와의 구조적 책임 매핑 작업”**을 정식 정의한 것이다.  
테스트는 단순 기능 실행 검증이 아니라, 각 상태 흐름이 설계 문서에서 어떤 책임으로 정의되어 있으며  
어떤 컴포넌트가 어떤 상태 전이에 개입하는지를 **명시적으로 분해**하고 대응시켜야 한다.

---

## ✅ 수행 목적 요약

- 테스트는 기능 실행 여부가 아니라, **설계자 의도대로 구현이 되어 있는지를 구조적으로 검증**해야 한다.
- 따라서 각 테스트 시나리오는 흐름에 참여하는 **설계 책임 단위(Triggerer, StateChanger, Finalizer 등)**를 반드시 명시하고,
- 이 책임이 어느 문서, 어느 메서드, 어느 자원 객체에 대응되는지를 추적 가능해야 한다.

---

## 🧭 책임 단위 분해 기준

| 책임 유형 | 정의 | 예시 |
|-----------|------|------|
| 상태 전이 트리거 책임자 (Triggerer) | 흐름 개시 조건을 판정하고 상태 전이를 시작하는 책임자 | RoomJoinService.confirmJoinRoom() |
| 상태 변화 실행자 (StateChanger) | 메모리 기반 상태 객체를 실제로 변경하는 책임자 | SemaphoreRegistry.tryAcquire(), release() |
| 상태 확정 반영자 (Finalizer) | DB, Redis, 세션 등에 상태를 반영하는 외부 적용자 | joinRoom(), ChatSessionRegistry.register() |
| 사후 정리 책임자 (PostCleaner) | 실패 흐름에서 자원을 회수하거나 복구하는 책임자 | afterConnectionClosed(), ChatServiceScheduler |
| 정합성 감시자 (StateVerifier) | 상태 불일치나 누락을 감지하고 이를 처리하는 감시자 | TTL 기반 스케줄러, 로그 감시 시스템 등 |

> 하나의 흐름 내에서 여러 책임 유형이 동시에 작동하며,  
> 이 책임 분리는 상태 흐름을 관측 가능하게 하고, 실패 시 설계 위반 여부를 판별할 수 있게 한다.

---

## 🗂️ 매핑 작성 방식

각 시나리오 흐름은 아래 항목에 따라 책임 구조를 명시해야 한다:

- **상태 흐름 식별자**: 흐름을 정의하는 식별 명칭 (예: WebSocket 연결 시 입장 확정 흐름)
- **설계 문서 출처**: 클래스/메서드가 명시된 문서 파일과 위치 (예: ChatTextWebSocketHandler.java.md / afterConnectionEstablished)
- **참여 책임 단위 상세**:
    - Triggerer: 흐름 시작 조건의 판별자
    - StateChanger: 상태 객체 수정자
    - Finalizer: 외부 시스템 반영자
    - PostCleaner: 실패 흐름 회수자
    - StateVerifier: 불일치 감시자
- **실행 시점**: 각 책임 단위가 호출되는 정확한 시스템 타이밍
- **전이 대상 필드**: 객체 내부에서 변경되는 데이터 키, 필드, 구조
- **전이 흐름 내 위치**: 전체 흐름 중 이 책임이 위치하는 단계 (초기, 중간, 말단 등)
- **설계 상 보장 조건**: 이 책임이 실패하거나 누락되었을 때 발생할 수 있는 설계 불일치 결과

---

> 이 매핑 구조는 Assertion 구성과 실패 진단, 책임 경계 판별의 기반이 되며  
> 테스트를 단순 실행 확인에서 벗어나 **설계 검증 시스템으로 격상시키는 핵심 전제 구조**이다.