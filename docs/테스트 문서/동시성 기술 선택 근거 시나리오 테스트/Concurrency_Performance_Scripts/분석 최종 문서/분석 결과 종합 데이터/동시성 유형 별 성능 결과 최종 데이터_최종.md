# 동시성 메커니즘 테스트 결과 데이터 정리

## 1. 테스트 환경 및 조건
- **총 요청 수**: 2,000건
- **스레드 수**: 200개
- **목표 성공률**: 49.5%
- **테스트 대상**: IF_ELSE, Synchronized, ReentrantLock, Semaphore

## 2. Overall Summary (전체 요약)

| 메커니즘 | Total Requests | Success | Success Rate (%) | Capacity Failed | Entry Failed | Other Failed |
|----------|----------------|---------|------------------|----------------|--------------|--------------|
| **IF_ELSE** | 2,000 | 991 | 49.55% | 1,009 (50.45%) | 0 | - |
| **Synchronized** | 2,000 | 990 | 49.5% | 1,010 (50.5%) | 0 | - |
| **ReentrantLock** | 2,000 | 990 | 49.5% | 1,010 (50.5%) | 0 | PRE_CHECK_FAIL: 0 |
| **Semaphore** | 2,000 | 990 | 49.5% | 1,010 (50.5%) | - | UNKNOWN: 0 |

## 3. Success Case Statistics (성공 케이스 통계)

### 3.1 대기시간 분석

| 메커니즘 | 평균 (μs) | 중간값 (μs) | 최대값 (μs) | 총합 (μs) |
|----------|-----------|-------------|-------------|-----------|
| **IF_ELSE** | 48.4 | 22.0 | 1,609.1 | 47,933.3 |
| **Synchronized** | 353.1 | 25.2 | 44,233.7 | 349,558.1 |
| **ReentrantLock** | 2,109.5 | 52.4 | 164,034.8 | 2,088,409.1 |
| **Semaphore** | - | - | - | - |

### 3.2 실행시간 분석

| 메커니즘 | 평균 (μs) | 중간값 (μs) | 최대값 (μs) | 총합 (μs) |
|----------|-----------|-------------|-------------|-----------|
| **IF_ELSE** | 140.6 | 54.1 | 4,073.0 | 139,332.6 |
| **Synchronized** | 133.3 | 51.5 | 35,088.3 | 131,928.0 |
| **ReentrantLock** | 355.2 | 82.2 | 50,479.0 | 351,642.4 |
| **Semaphore** | 413.1 | 86.2 | 38,176.7 | 408,925.4 |

### 3.3 대기시간과 실행시간 합산 표

| 메커니즘 | 평균 (μs) | 중간값 (μs) | 최대값 (μs) | 총합 (μs) |
|----------|-----------|-------------|-------------|-----------|
| **IF_ELSE** | 189.0 | 76.1 | 5,682.1 | 187,265.9 |
| **Synchronized** | 486.4 | 76.7 | 79,322.0 | 481,486.1 |
| **ReentrantLock** | 2,464.7 | 134.6 | 214,513.8 | 2,440,051.5 |
| **Semaphore** | 413.1 | 86.2 | 38,176.7 | 408,925.4 |

## 4. Failed Case Statistics (실패 케이스 통계)

### 4.1 대기시간 분석

| 메커니즘 | 평균 (μs) | 중간값 (μs) | 최대값 (μs) | 총합 (μs) |
|----------|-----------|-------------|-------------|-----------|
| **IF_ELSE** | 83.2 | 20.8 | 7,061.0 | 83,900.1 |
| **Synchronized** | 631.3 | 53.4 | 12,816.1 | 637,594.7 |
| **ReentrantLock** | 4,094.8 | 2,385.8 | 25,784.0 | 4,135,748.5 |
| **Semaphore** | - | - | - | - |

### 4.2 실행시간 분석

| 메커니즘 | 평균 (μs) | 중간값 (μs) | 최대값 (μs) | 총합 (μs) |
|----------|-----------|-------------|-------------|-----------|
| **IF_ELSE** | 145.6 | 26.8 | 8,148.7 | 146,912.9 |
| **Synchronized** | 65.2 | 33.3 | 896.6 | 65,845.4 |
| **ReentrantLock** | 166.7 | 65.5 | 16,773.9 | 168,386.7 |
| **Semaphore** | 971.0 | 119.2 | 23,607.1 | 980,716.9 |

### 4.3 대기시간과 실행시간 합산 표

| 메커니즘 | 평균 (μs) | 중간값 (μs) | 최대값 (μs) | 총합 (μs) |
|----------|-----------|-------------|-------------|-----------|
| **IF_ELSE** | 228.8 | 47.6 | 15,209.7 | 230,813.0 |
| **Synchronized** | 696.5 | 86.7 | 13,712.7 | 703,440.1 |
| **ReentrantLock** | 4,261.5 | 2,451.3 | 42,557.9 | 4,304,135.2 |
| **Semaphore** | 971.0 | 119.2 | 23,607.1 | 980,716.9 |

## 5. 핵심 성능 지표 비교

### 5.1 성공 케이스 성능 순위 (Total Mean 기준)
1. **IF_ELSE**: 189.0μs (최고 성능)
2. **Semaphore**: 413.1μs
3. **Synchronized**: 486.3μs
4. **ReentrantLock**: 2,464.7μs (최저 성능)

### 5.2 실패 케이스 성능 순위 (Total Mean 기준)
1. **IF_ELSE**: 228.8μs (최고 성능)
2. **Synchronized**: 696.5μs
3. **Semaphore**: 971.0μs
4. **ReentrantLock**: 4,261.5μs (최저 성능)

### 5.3 Semaphore vs 다른 메커니즘 직접 비교

#### 성공 케이스에서 Semaphore 성능
- **vs IF_ELSE**: 2.2배 느림 (413.1μs vs 189.0μs)
- **vs Synchronized**: 15% 빠름 (413.1μs vs 486.3μs) ✅
- **vs ReentrantLock**: 6.0배 빠름 (413.1μs vs 2,464.7μs) ✅

#### 실패 케이스에서 Semaphore 성능
- **vs IF_ELSE**: 4.2배 느림 (971.0μs vs 228.8μs)
- **vs Synchronized**: 39% 느림 (971.0μs vs 696.5μs)
- **vs ReentrantLock**: 4.4배 빠름 (971.0μs vs 4,261.5μs) ✅

## 6. Sum 값을 통한 전체 처리 효율성 분석

### 6.1 성공 케이스 - 총 처리 시간 효율성 (Sum 기준)

| 메커니즘 | Total Sum (μs) | 평균 대비 효율성 | 전체 처리량 순위 |
|----------|----------------|------------------|------------------|
| **IF_ELSE** | 187,265.9 | 최고 효율 | 1위 |
| **Semaphore** | **408,925.4** | **중간 효율** | **2위** |
| **Synchronized** | 481,486.1 | 낮은 효율 | 3위 |
| **ReentrantLock** | 2,440,051.5 | 최저 효율 | 4위 |

### 6.2 실패 케이스 - 총 거부 처리 효율성 (Sum 기준)

| 메커니즘 | Total Sum (μs) | 평균 대비 효율성 | 실패 처리량 순위 |
|----------|----------------|------------------|------------------|
| **IF_ELSE** | 230,813.0 | 최고 효율 | 1위 |
| **Synchronized** | 703,440.1 | 중간 효율 | 2위 |
| **Semaphore** | **980,716.9** | **낮은 효율** | **3위** |
| **ReentrantLock** | 4,304,135.2 | 최저 효율 | 4위 |

### 6.3 개별 컴포넌트 Sum 분석 (IF_ELSE 기준)

**성공 케이스 - IF_ELSE 세부 분석**
- Wait Time Sum: 47,933.3μs
- Dwell Time Sum: 139,332.6μs
- 총합: 187,265.9μs

**실패 케이스 - IF_ELSE 세부 분석**  
- Wait Time Sum: 83,900.1μs
- Fail Processing Sum: 146,912.9μs
- 총합: 230,813.0μs

---

## 주요 성능 분석 결과

### 전체 성능 순위 (성공 케이스 기준)
1. **IF_ELSE**: 189.0μs - 최고 성능
2. **Semaphore**: 413.1μs - 2위
3. **Synchronized**: 486.3μs - 3위  
4. **ReentrantLock**: 2,464.7μs - 최저 성능

### Semaphore의 특징적 성능

**성공 케이스에서의 강점:**
- Synchronized 대비 **15% 빠름** (413.1μs vs 486.3μs)
- ReentrantLock 대비 **6배 빠름** (413.1μs vs 2,464.7μs)
- 전체 처리량에서 **2위** 달성

**주목할 점:**
- Semaphore는 **Wait Time이 측정되지 않음** - 이는 permit 기반 즉시 처리 방식 때문
- Processing Time이 "Permit Processing"으로 표시되어 다른 메커니즘과 구조적 차이 존재

### 실패 케이스 분석

**실패 처리 성능:**
- IF_ELSE 대비 **4.2배 느림** (971.0μs vs 228.8μs)
- Synchronized 대비 **39% 느림** (971.0μs vs 696.5μs)
- 하지만 ReentrantLock 대비 **4.4배 빠름**

### 핵심 인사이트

1. **IF_ELSE가 압도적 성능**: 단순 조건문이 가장 빠르지만, 실제 동시성 제어는 제한적

2. **Semaphore의 균형잡힌 성능**: 
   - 성공 케이스에서 Synchronized보다 우수
   - 실패 케이스 처리도 ReentrantLock보다 훨씬 효율적

3. **ReentrantLock의 오버헤드**: 
   - Wait Time이 매우 높음 (2,109.5μs)
   - 전체적으로 가장 느린 성능

### 권장사항

**Semaphore 사용을 권장하는 경우:**
- 동시 접근 제어가 필요하면서도 성능이 중요한 상황
- Synchronized보다 더 세밀한 제어가 필요한 경우
- 허가 기반의 직관적인 리소스 관리가 필요한 경우

이 테스트 결과는 Semaphore가 실용적인 동시성 제어와 성능 사이의 좋은 균형점을 제공함을 보여줍니다.