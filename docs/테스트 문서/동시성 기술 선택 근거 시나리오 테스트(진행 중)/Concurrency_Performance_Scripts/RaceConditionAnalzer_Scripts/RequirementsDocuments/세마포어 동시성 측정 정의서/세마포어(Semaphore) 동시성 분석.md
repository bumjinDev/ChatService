# 세마포어(Semaphore) 동시성 분석 포트폴리오 문서 - 완전판

## 개요

본 문서는 채팅 서비스에서 세마포어를 활용한 동시성 제어 방식을 분석하고, 기존 동시성 제어 방식(synchronized, ReentrantLock)과의 차이점을 검증한 과정을 포트폴리오 형태로 정리한 것입니다.

## 1. 세마포어의 정합성 분석 최종 수정안

### 1.1 분석 관점의 전환

**기존 접근법의 한계**
- synchronized와 ReentrantLock은 '상호 배제'를 통한 순차적 처리가 목적
- 세마포어는 '카운팅 자원'의 효율적인 분배가 목적
- 동일한 분석 기준 적용 시 본질적 차이를 간과할 위험

**새로운 분석 관점**
세마포어의 정합성 보장 범위를 확인하기 위해 '값 불일치'와 '상태 전이' 발생 여부를 검증하였다. 분석 결과, synchronized와 달리 두 유형의 오류가 모두 발생하는 것을 확인하였다.

하지만 **이는 세마포어의 결함이 아니라, 근본적인 설계 철학의 차이**에서 비롯된 동작 특성이다.

### 1.2 포트폴리오 본문 최종 수정안

이 새로운 관점을 바탕으로, 세마포어의 정합성 분석 파트 본문을 다음과 같이 작성합니다.

세마포어의 정합성 보장 범위를 확인하기 위해 '값 불일치'와 '상태 전이' 발생 여부를 검증하였다. 분석 결과, synchronized와 달리 두 유형의 오류가 모두 발생하는 것을 확인하였다.

하지만 이는 세마포어의 결함이 아니라, 근본적인 설계 철학의 차이에서 비롯된 동작 특성이다. synchronized가 '상호 배제'를 통해 엄격한 순서성을 보장하는 것과 달리, 세마포어는 '카운팅 자원'의 효율적인 분배를 목적으로 한다.

세마포어의 기반이 되는 CAS(Compare-And-Swap) 메커니즘은, 스레드를 재우고 깨우는 비싼 비용 없이 원자적으로 '허가(Permit) 개수'를 관리한다. 이 과정에서 순서보다는 경합에서 이긴 스레드가 먼저 자원을 획득하므로, 임계 구역에 진입한 스레드들이 공유 변수(currentPeople)를 비선형적으로 갱신하는 것은 자연스러운 결과이다.

결론적으로, 이 테스트는 세마포어가 시스템의 동시성 수준을 제어하는 데는 매우 효과적이지만, 임계 구역 내부 데이터의 순차적 일관성까지는 보장하지 않는다는 명확한 특성을 보여준다. 따라서 세마포어를 사용할 때는, 내부 공유 자원에 대해 AtomicInteger와 같은 추가적인 원자성 보장 장치를 함께 사용하는 것이 필수적임을 확인하였다.

## 2. 세마포어 정합성 분석 최종 계획

### 2.1 Semaphore(non-fair): '예상된 혼돈'의 증명

**테스트 목표**
세마포어의 비공정 모드가 IF-ELSE와 마찬가지로 데이터 정합성을 보장하지 않음을 데이터로 증명한다.

**실행 계획**
1. Semaphore(non-fair) 모드로 테스트를 실행한다.
2. 기존 분석 스크립트를 사용하여 규칙 1(값 불일치)과 규칙 4(상태 전이) 오류가 발생하는 것을 데이터로 보여준다.
3. 동시에 규칙 3(정원 초과) 오류는 발생하지 않았음을 보여준다.

**포트폴리오 서술**
> "Semaphore(non-fair)는 시스템의 최대 동시 처리량(정원)은 성공적으로 제어했지만, 임계 구역 내부 연산의 원자성까지는 보장하지 못하여 IF-ELSE와 동일한 데이터 정합성 오류가 발생함을 확인했다."

### 2.2 Semaphore(fair): '측정의 한계' 인정 및 '성능'에 집중

**테스트 목표**
순서 기반 정합성 분석의 한계를 명확히 밝히고, 분석의 초점을 '성능 트레이드오프'로 전환한다.

**실행 계획**
1. Semaphore(fair) 모드로 테스트를 실행한다.
2. 규칙 1과 4에 대한 데이터는 '참고용'으로만 사용하고, 포트폴리오 본문에는 포함시키지 않거나, 한계를 명시하고 첨부한다.
3. **규칙 3(정원 초과) 오류는 여전히 0%**임을 명확히 보여준다.
4. 가장 중요한 것은, non-fair 모드와 fair 모드의 성능 지표(총 소요 시간, p99, CPU 사용량 등)를 비교 분석하는 데 모든 서술을 집중한다.

**포트폴리오 서술 (가장 중요한 부분)**
> "Semaphore(fair)의 정합성을 검증하는 과정에서, 외부에서 관측되는 '로그 기록 순서'와 세마포어 내부의 실제 '스레드 처리 순서'가 다를 수 있다는 측정의 한계를 발견하였다. 이는 '상태 전이 오류'와 같은 순서 기반 분석의 신뢰도를 떨어뜨릴 수 있다.
> 
> 따라서 Semaphore(fair)에 대해서는, 명확하게 검증 가능한 '정원 초과 방지'는 100% 성공했음을 데이터로 증명하고, 분석의 초점을 **non-fair 모드와의 '성능 트레이드오프'**에 맞추었다."

## 3. 세마포어의 동시 실행(Concurrency) 제어 분석

### 3.1 분석 관점의 전환

**기존 분석의 한계**
synchronized와 ReentrantLock의 경합 분석은 '상호 배제'가 잘 지켜지는지를 확인하는 것이 목표였다. 하지만 세마포어는 N개의 스레드가 동시에 실행되는 것을 허용하므로, 분석의 관점을 '오류 탐지'에서 **'동시 실행 패턴 관찰'**로 전환하였다.

### 3.2 동시 실행 패턴의 의미

**허용된 겹침 현상**
제공된 데이터와 같이, 세마포어는 허가(Permit) 개수 내에서 여러 스레드의 '실행 구간'이 시간적으로 겹치는 것을 허용한다. 이는 단일 스레드만 허용하던 이전 잠금 방식들과의 근본적인 차이점이며, 세마포어가 '처리량'을 높이는 데 어떻게 기여하는지를 보여준다.

**CAS 메커니즘의 관찰**
이러한 효율적인 동시 실행은 세마포어의 기반이 되는 CAS(Compare-And-Swap) 메커니즘 덕분이다. 스레드들은 비싼 OS 수준의 잠금을 기다리는 대신, CAS 연산을 통해 가볍게 허가를 획득하려 시도한다. 이 과정을 통해 관측된 '겹치는 실행 구간'은, CAS가 어떻게 애플리케이션 레벨에서 높은 수준의 동시성(High Concurrency)을 가능하게 하는지를 표면적으로나마 관찰한 결과라고 할 수 있다.

## 4. 포트폴리오를 위한 최종 분석 계획

이 통찰을 바탕으로, 세마포어의 정합성 분석 계획을 다음과 같이 수정하는 것이 가장 적절하다.

### 4.1 규칙 1과 4: '순차적 일관성 검증'으로 통합

**분석 목표**
세마포어가 임계 구역 내 작업의 순차적 일관성을 보장하지 못함을 증명한다.

**검증 방법**
`room_entry_sequence`를 기반으로 계산된 '기대 인원수'와, 실제 기록된 '현재 인원수'(`actual_curr_people`)를 비교하는 라인 그래프를 제시한다.

**결론**
그래프에서 두 선이 일치하지 않는 것을 통해, 세마포어가 동시 접근 '개수'는 제어하지만, 작업의 스레드 간 '순서'는 보장하지 않는다는 한계를 명확히 보여준다.

### 4.2 규칙 2 (경합): '의도된 동시 실행'으로 분석

**분석 접근법**
세마포어가 허용하는 '겹치는 실행 구간'을 통해, CAS 기반 동작의 특성을 설명하는 용도로 활용한다.

### 4.3 규칙 3 (정원 초과): '성공 사례'로 분석

**분석 목표**
세마포어의 본래 목적인 '최대 동시 접근 제어'는 완벽하게 수행했음을 데이터로 증명한다.

## 5. 기술적 구현 세부사항

### 5.1 세마포어 전처리 스크립트 최적화

**기존 동시성 제어와의 차이점**
- **이벤트 매핑**: `PRE_JOIN_CURRENT_STATE` → `JOIN_PERMIT_ATTEMPT`
- **데이터 의미**: `currentPeople` = permit 개수 (인원수가 아님)
- **expected_people**: 세마포어에서는 개념 자체가 적용 불가하여 컬럼 제거

**최종 CSV 구조 (10개 컬럼)**
1. `roomNumber` - 방 번호
2. `bin` - 분석 구간
3. `user_id` - 사용자 ID
4. `prev_people` - permit 시도 전 개수
5. `curr_people` - permit 시도 후 개수
6. `max_people` - 최대 정원
7. `room_entry_sequence` - 입장 순번
8. `join_result` - 성공/실패
9. `true_critical_section_nanoTime_start` - 시작 나노초
10. `true_critical_section_nanoTime_end` - 종료 나노초

### 5.2 페어링 로직 최적화

**세마포어 특화 매칭**
```python
# JOIN_PERMIT_ATTEMPT → JOIN_PERMIT_SUCCESS/FAIL 매칭
if current_row['event'] == 'JOIN_PERMIT_ATTEMPT':
    # 같은 사용자의 SUCCESS/FAIL 이벤트 탐색
    if (next_row['userId'] == pre_event['userId'] and 
        next_row['event'] in ['JOIN_PERMIT_SUCCESS', 'JOIN_PERMIT_FAIL']):
```

**나노초 정밀도 기반 정렬**
- 정확한 시간순 분석을 위한 나노초 단위 정렬
- `true_critical_section_nanoTime_start` 기준 최종 정렬

## 6. 결론 및 시사점

### 6.1 세마포어의 역할과 위치

**명확한 역할 정의**
- ✅ 동시성 수준 제어: 뛰어난 성능
- ✅ 최대 동시 접근 제한: 완벽한 보장
- ❌ 순차적 일관성: 보장하지 않음

**실무 적용 가이드라인**
세마포어 사용 시 내부 공유 자원에 대한 추가적인 원자성 보장 장치(AtomicInteger 등) 필수 병행 사용

### 6.2 동시성 제어 방식 비교 종합

| 구분 | synchronized | ReentrantLock | Semaphore |
|------|--------------|---------------|-----------|
| **목적** | 상호 배제 | 명시적 잠금 | 자원 개수 제어 |
| **동시 실행** | 1개 스레드만 | 1개 스레드만 | N개 스레드 허용 |
| **순차적 일관성** | 보장 | 보장 | 보장하지 않음 |
| **성능** | 보통 | 높음 | 매우 높음 |
| **적용 시나리오** | 간단한 동기화 | 복잡한 동기화 | 처리량 최적화 |

### 6.3 포트폴리오 핵심 메시지

본 분석을 통해 **동시성 제어 방식의 선택이 단순한 성능 문제가 아닌, 설계 철학과 요구사항에 따른 근본적인 아키텍처 결정**임을 확인할 수 있었다. 세마포어는 높은 처리량을 요구하는 시스템에서 매우 효과적이지만, 데이터 일관성에 대한 추가적인 고려가 반드시 필요함을 실험을 통해 증명하였다.

---

**문서 작성일**: 2025년 7월 22일  
**분석 대상**: 채팅 서비스 동시성 제어 시스템  
**기술 스택**: Java, Spring Boot, Semaphore, Python 분석 도구