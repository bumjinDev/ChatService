# 동시성 제어 구조 성능 테스트 계획서

## 개요
채팅방 입장 시스템의 동시성 제어 방식별 성능 및 정합성 비교 분석을 위한 테스트 계획서이다. 본 테스트는 다른 모든 동기화 기법의 성능 오버헤드와 정합성 개선 효과를 측정하기 위한 명확한 '기준선(Baseline)'을 수립하는 과정부터 시작한다.

---

## 테스트 1: IF-ELSE (제어 없음) 구조 분석

### 테스트 목표 (Test Objective)

**성능 관점**: 동기화 로직이 전혀 없을 때, 시스템이 보여줄 수 있는 이론상의 최고 성능(처리 속도)을 측정한다.

**정합성 관점**: 이전 프로젝트에서 분석한 '값 불일치', '정원 초과' 등의 오류가 동일한 조건에서 확실하게 재현됨을 다시 한번 확인하여 문제 상황을 명확히 정의한다.

### 테스트 대상 옵션 (Test Options)
제어 없는 IF-ELSE 구조는 그 자체가 하나의 명확한 비교군이므로, 별도의 내부 옵션은 없다. 현재 보유하고 있는 `RoomJoinServiceIfElse.java`의 로직 그대로를 테스트 대상으로 사용한다.

### 분석 관점 및 핵심 지표 (Analysis Perspective & Key Metrics)
IF-ELSE 테스트 결과를 볼 때는 **"정합성을 포기했을 때, 우리는 속도에서 얼마나 이득을 보는가?"** 라는 관점으로 접근해야 한다.

#### 성능 지표 (Performance Metrics)

**평균/중앙값 실행 시간 (Mean/Median)**: 잠금으로 인한 지연이 전혀 없는 상태의 순수한 비즈니스 로직 처리 속도를 확인한다. 이 값이 모든 테스트 중 가장 낮게(가장 빠르게) 나와야 한다.

**99th Percentile (p99) 실행 시간**: 잠금이 없음에도 불구하고, OS 스케줄링이나 가비지 컬렉션(GC) 등 외부 요인에 의해 발생할 수 있는 최대 지연 시간을 확인한다.

#### 정합성 지표 (Consistency Metrics)

**오류 발생률**: '값 불일치', '정원 초과' 등 규칙 1~4에 해당하는 오류가 전체 요청 중 몇 퍼센트에서 발생하는지 측정하여, "제어 없는 구조는 이 정도의 위험성을 내포한다"는 것을 수치로 보여준다.

### 기술적 배경 (Technical Background)
IF-ELSE 구조의 결과를 해석할 때는 다음 두 가지 기술적 배경을 고려해야 한다.

#### 비원자적 연산 (Non-Atomic Operation)
`if (인원수 < 최대인원)` 이라는 확인(Check) 단계와 `인원수++` 라는 조치(Act) 단계가 분리되어 있다. CPU는 이 두 명령을 별개의 작업으로 처리하기 때문에, 한 스레드가 Check와 Act를 수행하는 그 찰나의 순간에 다른 수십 개의 스레드가 끼어들 수 있다. 이것이 모든 오류의 근본 원인이다.

#### 메모리 가시성 (Memory Visibility)
멀티코어 환경에서는 한 스레드가 수정한 값이 다른 스레드에게 즉시 보이지 않을 수 있다. `volatile`이나 동기화 블록은 이 가시성을 보장해주지만, 단순 IF-ELSE는 그렇지 못하다. 이로 인해 일부 스레드는 이미 변경된 값을 보지 못하고 오래된 값을 기준으로 작업하여 오류를 발생시킨다.

본 테스트가 완료되면, 다른 모든 동기화 방식의 '비용(Cost)'을 측정할 수 있는 명확한 **'기준선(Baseline)'**을 확보하게 된다.

---

## 테스트 2: synchronized 블록/메서드 구조 분석

`synchronized`는 JVM에 내장된 가장 기본적인 동기화 메커니즘이다. 본 테스트의 목적은 `synchronized`가 정합성 문제를 확실히 해결하는지 확인하고, 그 대가로 얼마나 큰 성능 비용(Overhead)을 지불하는지 측정하는 것이다.

### 테스트 목표 (Test Objective)

**정합성 관점**: `synchronized`를 적용했을 때, '값 불일치', '정원 초과' 등 이전에 발견된 모든 정합성 오류의 발생률이 0%가 되는지를 확인하여 동기화 효과를 검증한다.

**성능 관점**: IF-ELSE(제어 없음) 기준선(Baseline)과 비교하여, synchronized 블록 진입/이탈 시 발생하는 락 획득(Acquire) 및 해제(Release) 오버헤드를 정량적으로 측정한다.

### 테스트 대상 옵션 (Test Options)
`synchronized`는 두 가지 방식으로 적용할 수 있으며, 이 둘의 성능 특성을 비교하는 것도 의미 있는 분석이 될 수 있다.

- **synchronized 메서드**: 메서드 전체를 동기화하는 방식. `public synchronized void joinRoom() { ... }`
- **synchronized 블록**: 메서드 내 특정 코드 블록만 동기화하는 방식. `synchronized(this) { ... }`

일반적으로 임계 구역의 범위를 최소화하는 synchronized 블록 방식이 권장된다. 테스트에서는 이 방식을 채택하여 임계 구역을 명확히 제어하는 것이 좋다.

### 분석 관점 및 핵심 지표 (Analysis Perspective & Key Metrics)
`synchronized`의 결과를 볼 때는 **"데이터 정합성을 얻는 대가로, 성능(속도와 안정성) 측면에서 무엇을 얼마나 잃었는가?"** 라는 관점으로 접근해야 한다.

#### 성능 지표 (Performance Metrics)

**평균/총합 실행 시간 (Mean/Median)**: IF-ELSE 모델과 비교하여 순수한 락 오버헤드가 평균적으로 얼마나 되는지 측정한다. 이 차이가 클수록 synchronized의 비용이 크다는 의미이다.

**99th Percentile (p99)**: **synchronized 분석의 핵심이다**. synchronized는 기본적으로 비공정(Non-fair) 락이므로, 운 나쁜 스레드는 다른 스레드에게 계속 순서를 뺏겨 하염없이 대기할 수 있다(기아 현상). 이 현상은 p99 값을 비정상적으로 높인다. 평균은 괜찮아 보여도 p99 값이 크게 튀었다면, 이는 시스템의 안정성이 낮다는 강력한 증거이다.

#### 정합성 지표 (Consistency Metrics)
- **모든 오류 발생 건수**: 0건
- **모든 오류 발생률**: 0%

### 기술적 배경 (Technical Background)
결과를 해석할 때 아래의 기술적 배경을 함께 고려해야 한다.

#### 고유 락 (Intrinsic Lock / Monitor)
모든 자바 객체는 '고유 락'이라는 것을 하나씩 가지고 있다. `synchronized`는 이 고유 락을 이용하여 특정 시점에 단 하나의 스레드만 코드 블록에 접근하도록 보장(상호 배제, Mutual Exclusion)한다.

#### 메모리 가시성 (Memory Visibility)
`synchronized`는 단순한 잠금 이상의 역할을 한다. 스레드가 synchronized 블록에 진입할 때, 이전 스레드가 남긴 모든 변경 사항을 메인 메모리로부터 읽어오는 것을 보장한다. 블록을 나갈 때는 자신의 변경 사항을 메인 메모리에 기록한다. 이 '메모리 배리어(Memory Barrier)' 역할 덕분에 데이터 정합성 문제가 해결되는 것이다.

#### 비공정성 (Non-Fairness)
JVM은 전체 처리량(Throughput)을 높이기 위해, 대기 큐에서 가장 오래 기다린 스레드 대신 방금 도착한 스레드에게 락을 주는 것을 허용한다. 이 때문에 일부 스레드의 대기 시간이 길어져 성능의 예측 가능성이 떨어질 수 있다.

본 테스트가 완료되면 IF-ELSE와 synchronized의 결과를 비교하여, **"안전하지만, 때로는 불공평하고 예측하기 힘든 비용을 치른다"**는 결론을 데이터로 증명할 수 있다.

---

## 테스트 3: ReentrantLock 구조 분석

`ReentrantLock`은 `synchronized`보다 더 유연하고 강력한 기능을 제공하는 잠금 도구이다. 본 테스트는 ReentrantLock의 핵심 옵션들을 활용하여 성능 특성을 심층적으로 분석하고, 각 선택지가 가지는 명확한 트레이드오프 관계를 데이터로 증명하는 것을 목표로 한다.

### 테스트 목표 (Test Objective)

**synchronized와의 성능 비교**: synchronized와 동일한 조건(비공정 모드)에서 ReentrantLock의 성능을 측정하여, 구현 방식의 차이가 실제 성능에 미치는 영향을 확인한다.

**공정성(Fairness) 정책에 따른 성능 변화를 데이터로 증명**하여, '처리량'과 '예측 가능성' 사이의 트레이드오프 관계를 분석한다.

**tryLock과 같은 논블로킹(Non-blocking) 방식의 가능성과 그 한계를 탐구**하고, 실무적인 개선 방향을 고찰한다.

### 테스트 대상 옵션 (Test Options)
ReentrantLock의 가장 중요한 설정인 '공정성' 여부에 따라 두 가지 시나리오를 테스트해야 한다.

#### 테스트 A: ReentrantLock (Non-fair) - 비공정 락 (기본값)
- **구현**: `Lock lock = new ReentrantLock();` 또는 `new ReentrantLock(false);`
- **동작**: synchronized와 유사하게, 락을 기다리는 순서를 보장하지 않아 '새치기'가 가능하다. 처리량에 유리할 수 있다.

synchronized와 비교하기 위한 기준선으로, 처리량에 이점이 있을 수 있다.

#### 테스트 B: ReentrantLock (Fair) - 공정 락
- **구현**: `Lock lock = new ReentrantLock(true);`
- **동작**: 락을 요청한 순서대로(FIFO) 획득하는 것을 보장한다. '기아(Starvation)' 현상을 방지하지만, 대기열을 관리하는 비용이 추가된다.

대기 순서를 보장하여 '기아(Starvation)' 현상을 방지하는 방식이다. 안정성 측면의 이점을 분석한다.

#### (탐구) 테스트 C: ReentrantLock + tryLock()
- **구현**: `if (lock.tryLock()) { ... }`
- **동작**: 락을 기다리지 않고 즉시 반환하는 논블로킹 방식의 성능 특성을 탐구한다.

### 분석 관점 및 핵심 지표 (Analysis Perspective & Key Metrics)
ReentrantLock의 결과를 볼 때는 **"더 많은 기능과 옵션을 제공하는 고급 잠금 방식은 어떤 대가를 치르며, 어떤 이점을 주는가?"** 라는 관점으로 접근해야 한다.

#### 관점 1: ReentrantLock(Non-fair) vs synchronized
두 비공정 락의 성능을 직접 비교한다. 특히 높은 경합 상황에서 AQS 기반의 ReentrantLock이 JVM 내장 락인 synchronized보다 더 나은 성능을 보이는지 확인하는 것이 흥미로운 분석 포인트가 될 수 있다.

#### 관점 2: ReentrantLock(Non-fair) vs ReentrantLock(Fair)
- **평균/총합값**: 공정 락(Fair)이 대기열 관리 오버헤드로 인해 비공정 락(Non-fair)보다 미세하게 느릴 것으로 예상된다.
- **99th Percentile (p99) / 총합 값**: **분석의 하이라이트이다**. 공정 락은 기아 현상을 방지하므로, 비공정 락에 비해 p99 값과 총합 값이 현저히 낮게 측정될 것이다. 이는 **'약간의 평균 성능 손실로, 훨씬 뛰어난 안정성과 예측 가능성을 확보했다'**는 강력한 증거가 된다.

두 모드의 평균/총합/p99 값을 비교한다. 공정 락이 약간의 평균 성능을 희생하는 대신, p99 지표와 표준편차를 얼마나 크게 개선하여 시스템의 안정성과 예측 가능성을 확보하는지를 중점적으로 분석한다.

### 기술적 배경 및 고찰 (Technical Background & Insights)
결과를 해석할 때 아래의 기술적 배경을 함께 고려해야 한다.

#### AQS (AbstractQueuedSynchronizer)
ReentrantLock은 `java.util.concurrent` 패키지의 핵심인 AQS 프레임워크를 기반으로 구현된다. 이는 스레드 대기열, 상태 관리 등을 매우 효율적으로 처리하는 동기화 메커니즘의 뼈대이다. synchronized의 방식보다 더 정교하고 유연한 제어가 가능하며, 공정성 정책과 같은 고급 기능의 구현을 가능하게 한다.

#### 공정성 정책의 구현 원리
- **Fair Lock**: 락을 요청한 스레드는 큐에 다른 스레드가 있는지 확인하고, 있다면 무조건 큐의 맨 뒤에 줄을 선다.
- **Non-fair Lock**: 락을 요청한 스레드는 큐를 확인하기 전에 일단 락 획득을 한번 시도한다(새치기). 성공하면 바로 작업을 시작하고, 실패했을 때만 큐에 줄을 선다. 이 '일단 시도'하는 과정 때문에 평균 처리량이 더 높게 나올 수 있다.

#### 재진입성 (Reentrancy)
이름에서 알 수 있듯, 이미 락을 보유한 스레드가 동일한 락을 다시 획득하려 할 때, 대기 없이 즉시 획득할 수 있는 특성을 가진다. 이는 synchronized도 마찬가지이다.

#### 잠금 비용 최적화 패턴 고찰
단순 `lock()-unlock()` 구조는, 임계 구역 진입 조건(예: `currentPeople < maxPeople`)이 거짓일 때도 불필요한 락 경쟁을 유발하는 비효율이 있다. 실무에서는 이를 개선하기 위해, 락을 잡기 전에 조건을 먼저 한번 확인하는 '이중 확인 잠금(Double-Checked Locking)' 패턴을 사용하여 불필요한 경합을 줄이는 최적화를 고려할 수 있다.

또한, tryLock의 낮은 성공률 문제를 보완하기 위해, 실패 시 즉시 포기하는 대신 일정 시간 간격을 두고 재시도하는 '재시도(Retry) 및 지수적 백오프(Exponential Backoff)' 전략을 적용하여 시스템의 안정성과 성공률을 높이는 방안을 추가적으로 탐구할 수 있다.

이 두 가지 ReentrantLock 테스트 결과를 이전의 IF-ELSE, synchronized와 함께 비교하면, '정합성, 성능, 안정성, 공정성'이라는 여러 축에서 각 동기화 방식이 어떤 위치에 있는지 명확하게 보여주는, 매우 수준 높은 분석 자료를 만들 수 있다.

---

## 테스트 4: Semaphore 구조 분석

`Semaphore`는 락(Lock)과는 다른 접근 방식을 제공한다. 하나의 스레드만 통과시키는 것이 아니라, 정해진 개수(N)의 스레드만 동시에 접근하도록 허용하는 동기화 도구이다. 본 테스트는 Semaphore를 이용해 '채팅방의 최대 정원'만큼만 동시 입장을 허용하는 시나리오를 분석하는 것을 목표로 한다.

### 테스트 목표 (Test Objective)

**정합성 관점**: Semaphore의 허가(Permit) 개수를 방의 최대 정원(max_people)으로 설정하여, '정원 초과' 오류를 원천적으로 방지할 수 있는지 검증한다.

**성능 관점**: 허가를 획득(acquire)하고 반납(release)하는 과정에서 발생하는 성능 오버헤드를 측정하고, 이를 다른 잠금 방식들과 비교 분석한다.

**자원 제어 관점**: 시스템이 감당할 수 있는 수준으로 동시 처리량을 제어하고, 과도한 요청으로부터 시스템을 보호하는 '안전장치'로서의 역할을 확인한다.

### 테스트 대상 옵션 (Test Options)
Semaphore의 핵심은 생성 시 주입하는 '허가(Permit)의 개수'이다.

#### 테스트 A: Semaphore(max_people)
- **구현**: `Semaphore semaphore = new Semaphore(max_people);`
- **동작**: 각 채팅방마다, 해당 방의 최대 정원수만큼의 허가권을 가진 세마포를 생성한다. 입장하려는 스레드는 `semaphore.acquire()`를 호출하여 허가권을 얻어야만 임계 구역에 진입할 수 있다. 허가권이 없으면 다른 스레드가 나갈 때까지 대기한다.

#### (심화) 테스트 B: Semaphore(max_people, true) - 공정 모드
- **구현**: `Semaphore semaphore = new Semaphore(max_people, true);`
- **동작**: ReentrantLock과 마찬가지로, 허가권을 기다리는 스레드들에게 공정하게(먼저 온 순서대로) 허가권을 분배한다.

### 분석 관점 및 핵심 지표 (Analysis Perspective & Key Metrics)
Semaphore의 결과를 볼 때는 **"단순히 막는(Blocking) 것을 넘어, 동시성의 '흐름(Flow)' 자체를 제어하는 방식은 어떤 장단점을 가지는가?"** 라는 관점으로 접근해야 한다.

#### 성능 지표 (Performance Metrics)

**평균/총합 값 실행 시간 (Mean/Median)**: 허가를 획득하고 반납하는 과정의 평균적인 비용을 측정한다. ReentrantLock과 비교했을 때, 경합이 적은 상황에서는 더 가볍게 동작할 수 있다.

**처리량 (Throughput)**: **본 테스트에서 중요한 지표이다**. Semaphore는 동시에 처리되는 작업의 수를 max_people로 제한하므로, 시스템 전체가 안정적으로 유지되는 대신 단위 시간당 최대 처리량이 명확한 한계를 가질 것이다. 이 한계점을 측정하는 것이 중요하다.

**99th Percentile (p99)**: 공정 모드(fairness=true)를 사용했을 때, 이 지표들이 비공정 모드에 비해 얼마나 안정적으로 나타나는지 비교 분석한다.

#### 정합성 지표 (Consistency Metrics)

**정원 초과 오류 발생률**: 0%.

### 기술적 배경 (Technical Background)

#### 허가(Permit) 기반 제어
Semaphore는 '잠금'이 아니라 '허가증' 개념이다. 입장권(Permit)이 있어야만 들어갈 수 있고, 나오면서 입장권을 반납하는 방식과 같다. 이 때문에 여러 스레드의 동시 접근을 허용하는 유연한 제어가 가능하다.

#### synchronized, ReentrantLock과의 근본적 차이
- **synchronized와 ReentrantLock**: **상호 배제(Mutual Exclusion)**가 목적이다. 즉, 임계 구역에는 오직 하나의 스레드만 들어갈 수 있다.
- **Semaphore**: **동시 접근 제어(Concurrent Access Control)**가 목적이다. 임계 구역에 N개의 스레드가 동시에 들어가는 것을 허용한다. 이 차이를 명확히 인지하는 것이 중요하다.

---

## 전체 테스트 비교 분석 프레임워크

### 4차원 분석 축
각 테스트 완료 후 데이터 기반으로 다음 질문들에 답할 수 있는 분석 자료를 완성해야 한다:

1. **정합성**: 데이터 무결성 보장 수준
2. **성능**: 평균 처리 속도  
3. **안정성**: 예측 가능성 (p99, 표준편차)
4. **공정성**: 스레드 간 균등한 기회 보장

### 핵심 질문들
1. **"완전한 안전성을 위해 얼마나 많은 성능을 포기해야 하는가?"**
2. **"공정성 보장은 정말로 시스템 안정성을 높이는가?"**  
3. **"실무에서 가장 균형 잡힌 선택지는 무엇인가?"**

### 예상 결과 매트릭스
| 동시성 방식 | 정합성 | 평균 성능 | p99 안정성 | 공정성 | 처리량 제한 | 주요 특징 |
|-------------|--------|-----------|------------|--------|------------|----------|
| IF-ELSE | 불완전 | 최고 (기준선) | 불안정 | 무관 | 없음 | 기준선, 값 불일치 발생 |
| synchronized | 완전 | 중간 | 높은 변동성 | 비공정 | 없음 | JVM 내장, 기아 현상 가능 |
| ReentrantLock(Non-fair) | 완전 | 중간 | 높은 변동성 | 비공정 | 없음 | AQS 기반, 유연성 높음 |
| ReentrantLock(Fair) | 완전 | 낮음 | 매우 안정 | 완전 공정 | 없음 | 순서 보장, 예측 가능 |
| ReentrantLock(tryLock) | 부분적 | 높음 | 성공률 의존적 | 무관 | 없음 | 논블로킹, 즉시 응답 |
| Semaphore(Non-fair) | 부분적 | 낮음 | 높은 변동성 | 비공정 | max_people | 동시 접근 제어 |
| Semaphore(Fair) | 부분적 | 가장 낮음 | 안정적 | 완전 공정 | max_people | 공정한 자원 분배 |

### 상세 분석 방향

#### 성능 vs 정합성 트레이드오프
- **IF-ELSE**: 최고 성능, 최악의 정합성
- **synchronized/ReentrantLock**: 완전한 정합성, 적절한 성능 비용
- **Semaphore**: 부분적 정합성(정원 제어만), 처리량 제한

#### 공정성 vs 처리량 트레이드오프  
- **Non-fair 모드**: 높은 처리량, 기아 현상 위험
- **Fair 모드**: 예측 가능한 성능, 약간의 처리량 손실

#### 실무 적용 가이드라인

**높은 처리량이 최우선인 경우**
- 단일 스레드 환경이거나 정합성이 중요하지 않다면: `IF-ELSE`
- 적절한 정합성과 처리량의 균형: `ReentrantLock(Non-fair)` 또는 `synchronized`

**안정성과 예측 가능성이 중요한 경우**  
- 공정성이 보장되어야 하는 시스템: `ReentrantLock(Fair)`
- 자원 풀링이나 동시 접근 수 제어: `Semaphore(Fair)`

**응답성이 중요한 실시간 시스템**
- 대기 없는 즉시 응답: `ReentrantLock.tryLock()` + 재시도 전략

### 측정 시 주의사항

#### 테스트 환경 통제 요소
- **하드웨어**: CPU 코어 수, 메모리 용량
- **동시성 수준**: 스레드 개수, 요청 빈도
- **부하 패턴**: 일정한 부하 vs 버스트 패턴

#### 워밍업 및 측정 방법론
- **통계적 유의성**: 충분한 반복 횟수와 신뢰 구간 계산

#### 결과 해석 시 고려사항

**p99 지표의 중요성**
- 평균이 좋아도 p99가 높다면 사용자 경험 악화
- 실제 서비스에서는 최악의 경우가 더 중요할 수 있음

**표준편차와 예측 가능성**
- 낮은 표준편차 = 일관된 성능 = 안정적인 시스템
- 높은 표준편차 = 성능 변동 심함 = 용량 계획 어려움

**처리량 vs 지연시간**
- 처리량이 높아도 개별 요청의 지연시간이 길 수 있음
- 시스템 특성에 따라 어느 쪽이 더 중요한지 판단 필요

### 결론 도출 템플릿

각 테스트 완료 후 다음 형식으로 결론을 정리한다:

#### 1. 수치적 비교
```
[방식명] vs IF-ELSE 기준선
- 평균 성능 오버헤드: +X%
- p99 개선/악화: ±Y%  
- 정합성 오류율: Z% → 0%
```

#### 2. 적용 권장 시나리오
```
[방식명]을 선택해야 하는 경우:
- 시스템 특성: [설명]
- 성능 요구사항: [설명]  
- 정합성 요구사항: [설명]
```

#### 3. 주의사항 및 한계
```
[방식명]의 한계점:
- 기술적 제약: [설명]
- 성능상 단점: [설명]
- 적용 시 고려사항: [설명]  
```

### 추가 심화 분석 방향

#### 하이브리드 접근 방식
- **이중 확인 잠금(Double-Checked Locking)**: 락 획득 전 조건 미리 확인
- **스핀락 + 슬립**: 짧은 대기는 스핀, 긴 대기는 블로킹
- **적응적 스핀**: 이전 락 보유 시간에 따라 스핀 시간 조절

#### 락프리(Lock-Free) 대안 탐구
- **AtomicInteger**: 원자적 연산을 통한 단순 카운터
- **CompareAndSwap(CAS)**: 락 없는 동시성 제어
- **성능 vs 복잡성**: 구현 난이도와 성능 이득의 균형점

#### 실제 운영 환경 고려사항
- **모니터링**: 락 경합 상황 실시간 감지
- **알람**: p99 지연시간 임계치 초과 시 알림
- **자동 조정**: 부하에 따른 동적 락 정책 변경

### 최종 분석 결과 활용 방안

#### 개발팀 가이드라인 수립
각 테스트 결과를 바탕으로 팀 내 동시성 제어 방식 선택 기준을 수립한다:

1. **성능 크리티컬 구간**: 어떤 방식을 우선 고려할 것인가
2. **안정성 크리티컬 구간**: 어떤 지표를 중점적으로 모니터링할 것인가
3. **공정성이 중요한 비즈니스 로직**: 어떤 구현 패턴을 적용할 것인가

#### 시스템 모니터링 지표 선정
테스트에서 중요하다고 입증된 지표들을 실제 운영 모니터링에 반영한다:

1. **p99 지연시간**: 사용자 경험 직결 지표
2. **락 경합률**: 시스템 확장성 판단 지표
3. **처리량 한계점**: 용량 계획 수립 기준

#### 코드 리뷰 체크리스트
테스트 결과를 바탕으로 동시성 관련 코드 리뷰 시 확인해야 할 항목들:

1. **동기화 범위**: 임계 구역이 최소화되었는가
2. **공정성 필요성**: 비즈니스 요구사항에 맞는 락 정책인가
3. **성능 임계점**: 예상 부하에서 acceptable한 성능인가
4. **fallback 전략**: tryLock 실패 시 적절한 대응책이 있는가

이러한 포괄적인 분석을 통해 각 동시성 제어 방식의 특성을 정확히 이해하고, 실무에서 최적의 선택을 할 수 있는 데이터 기반의 의사결정 자료를 확보할 수 있다.