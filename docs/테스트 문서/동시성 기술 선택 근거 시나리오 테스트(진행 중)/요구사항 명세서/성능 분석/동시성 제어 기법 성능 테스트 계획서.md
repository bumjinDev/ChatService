# 동시성 제어 기법 성능 테스트 계획서

## 1. 테스트 개요

### 1.1 테스트 목적
실시간 채팅 서비스와 같은 동시성이 중요한 시스템에서는 수많은 사용자의 동시 요청을 효율적이고 안정적으로 처리하는 것이 필수적이다. 본 테스트는 대표적인 동시성 제어 방식인 If-Else(뮤텍스 기반 방식), 세마포어, ReentrantLock, synchronized 방식을 비교 분석하여 어떤 구조가 실제 환경에서 가장 뛰어난 성능을 제공하는지를 확인하기 위한 것이다.

### 1.2 테스트 목표
- 각 동시성 제어 기법의 성공, 실패 유형별 **정확한 분포(비율)** 측정
- 높은 경합(High Contention) 상황에서의 **대기 시간 및 점유 시간 분포** 비교 분석
- 부하 누적에 따른 각 기법의 **성능 변화 추이** 및 **안정성** 파악 (`bin` 단위 분석)
- **방(Room) 단위별 성능 특성 비교** 및 **전체 통합 성능** 동시 분석
- 애플리케이션의 특성에 맞는 최적의 동시성 제어 기법을 선택하기 위한 객관적인 데이터 확보

### 1.3 테스트 범위
- **테스트 대상 동시성 기법:** `if-else (No-Lock)`, `synchronized`, `ReentrantLock (non-fair/fair)`, `Semaphore`
- **분석 수준:** 애플리케이션 레벨에서 수집된 로그를 기반으로, **`calculate_performance_stats.py`** 스크립트를 통해 생성된 정량적 지표 분석

### 1.4 테스트 시나리오
- **시나리오:** 200명의 가상 사용자를 1초 이내에 동시에 요청(Burst-Fire)하여, 시스템이 순간적인 최대 부하를 어떻게 처리하는지 측정한다.
- **측정:** 각 동시성 제어 기법을 적용하여 위 시나리오를 반복 실행하고, 결과를 개별적으로 기록한다.

### 1.5 문서 목적
본 문서는 Java/Spring Boot 환경에서 다양한 동시성 제어(Concurrency Control) 기법을 적용했을 때의 성능 특성을 정량적으로 측정하고, 데이터 기반으로 각 기법의 장단점을 분석하기 위한 테스트 계획 및 요구사항을 정의하는 것을 목적으로 한다.

## 2. 대상 시스템 및 환경

### 2.1 테스트 대상 시스템
- **Application:** 채팅방 입장 처리(`RoomJoinService`) 기능을 포함한 Java / Spring Boot 웹 애플리케이션
- **Core Logic:** 다수의 스레드가 동시에 특정 자원(채팅방 인원수)을 조회하고 갱신하는 로직

### 2.2 테스트 환경
- **Java/Spring Boot 환경**
- **JMeter를 이용한 부하 테스트**
- **로컬 서버 환경**

## 3. 측정 지표와 분석 방법

### 3.1 핵심 성능 지표와 실무적 근거
본 테스트는 **실시간 채팅 서비스의 방 입장 처리(`confirmJoinRoom`)**를 대상으로 하며, 각 측정 지표는 채팅방 동시 입장 상황에서의 실무적 의미를 가진다.

| 지표 | 측정 목적 | 채팅 서비스에서의 실무적 의미 |
|------|-----------|---------------------|
| 임계구역 대기시간(wait_time) | 채팅방 입장 응답 지연 최소화 | 사용자가 채팅방 입장 버튼을 누른 후 실제 입장까지의 대기시간 |
| 임계구역 실행시간(dwell_time) | 방 입장 처리 로직 효율성 평가 | 인원수 확인 및 증가 처리 시간 측정 |
| 진입 전 실패율 | 채팅 시스템 처리 한계 평가 | 락 획득 실패 등으로 방 입장 시도조차 못한 비율 |
| 진입 후 실패율 | 방 입장 과정에서의 자원 낭비 평가 | 락 획득 후 정원 초과로 실패한 비율 |

### 3.2 핵심 성능 지표(KPIs)

**결과 분포 지표**
- **요청 성공률 (%):** 전체 요청 중 최종 성공한 요청의 비율
- **진입 실패율 (%):** 락 획득 실패 등 임계 영역 진입 전 실패한 요청의 비율
- **정원 초과 실패율 (%):** 임계 영역 진입 후 비즈니스 로직(정원)에 의해 실패한 요청의 비율

**성공 성능 지표**
- **대기 시간 (Wait Time):** 락 획득을 위해 대기한 시간 (`critical_enter_time - waiting_start_time`)
- **임계 영역 실행 시간 (Dwell Time):** 락을 점유하고 비즈니스 로직을 수행한 시간 (`critical_leave_time - critical_enter_time`)

### 3.3 실무에서 성능 지표를 측정하는 배경과 근거

**임계구역 대기시간(wait_time)**
- **채팅 서비스에서 중요한 이유:** 사용자가 채팅방 입장 요청 후 실제 입장까지의 응답 시간에 직접적인 영향을 미친다. 대기시간이 길어지면 사용자가 느끼는 지연이 증가하여 사용자 경험이 악화된다.

**임계구역 실행시간(dwell_time)**
- **채팅 서비스에서 중요한 이유:** `getCurrentPeople()` 확인 및 `incrementCurrentPeople()` 처리 등 실제 방 입장 로직의 효율성을 나타낸다. dwell_time이 길수록 동시에 처리할 수 있는 입장 요청 수가 줄어들어 시스템 처리량이 저하된다.

**진입 전 실패율(Pre-entry failure rate)**
- **채팅 서비스에서 중요한 이유:** 락 획득 실패나 시스템 과부하로 방 입장 시도조차 못하는 상황을 측정한다. 이 비율이 높으면 채팅 서비스의 처리 용량이 부족함을 나타낸다.

**진입 후 실패율(Post-entry failure rate)**
- **채팅 서비스에서 중요한 이유:** 락을 획득했으나 정원 초과(`getCurrentPeople >= getMaxPeople`)로 실패하는 경우. 이는 시스템 자원을 낭비하는 비효율적인 처리 과정이다.

**성공률(success rate)**
- **채팅 서비스에서 중요한 이유:** 방 입장 성공률이 떨어지면 사용자 경험 저하로 직결되고, 채팅 서비스 이용률 하락으로 이어진다.

**처리량(Throughput)**
- **채팅 서비스에서 중요한 이유:** 단위 시간당 처리 가능한 방 입장 요청 수로, 채팅 서비스의 동시 사용자 수 확장성을 결정한다.

### 3.4 성능 분석 방법론 및 해석 가이드

**성공률(success_rate)**
- **측정 목적:** 실제로 성공한 요청의 비중, 시스템의 최대 효율성 측정
- **해석 기준:** 높을수록 시스템 품질이 우수함을 의미

**진입 전 실패율(capacity_failed_rate)**
- **측정 목적:** 락/세마포어/큐 등 구조적 한계로 진입조차 못한 요청의 비중
- **해석 기준:** 시스템 용량 한계를 나타내며, 높을 경우 자원 확장 필요

**진입 후 실패율(entry_failed_rate)**
- **측정 목적:** 락은 잡았으나 비즈니스 제약(최대 인원 등)으로 실패, 자원 낭비의 비중
- **해석 기준:** 높을 경우 사전 검증 로직 도입 필요

**상세 구간/케이스 분석 및 병목/비효율 구간 탐지**

**특정 bin/roomNumber에서 실패율이 급증하는 구간 주목**
- 해당 구간에서 특별한 병목이나 자원 경합이 발생했는지 분석

**성공률은 높은데 dwell_time이 긴 경우**
- 락 경쟁은 없으나 처리 로직이 병목임을 의미
- 로직 최적화 또는 임계구역 분할 검토 필요

**실패율이 높은데 wait_time도 높은 경우**
- 동시성 제어(락/세마포어) 구조 자체가 문제임을 의미
- 동시성 제어 방식 변경 검토 필요

### 3.5 실제 데이터 적용 방법

**표준 분석 흐름**
위의 **표준 분석 흐름**에 맞게, 엑셀/csv/py 파일에서 다음과 같이 진행한다:
- **roomNumber별, bin별, 구조별(If-Else/세마포어/락 등)로 결과를 정렬/집계**
- **각 케이스별 주요 rate/시간/실패 케이스**만 뽑아 표와 차트로 나열
- **단순 숫자 나열이 아니라, "왜 여기서 비효율/병목이 생기는가" 구조적으로 해설**
- **개선안은 "구조적으로 어디를 어떻게 바꿔야 어떤 메트릭이 좋아지는가"까지 명시**

**핵심 분석 질문**
데이터를 뽑는 것이 아닌, 다음 3가지를 집요하게 파고든다:
1. **"각 지표가 시스템의 어느 구조적 한계를 반영하는가"**
2. **"어디서 자원 낭비가 집중되는가"**
3. **"어떤 구조(락/세마포어 등)가 실질적 병목 원인인가"**

## 4. 동시성 제어 기법별 특성 분석

### 4.1 동시성 제어 방식의 구조적 특징 분석

**구조별 병목 발생 지점**

| 구조 유형 | 병목 지점 | 특징과 실무적 문제 |
|-----------|-----------|-------------------|
| If-Else (synchronized, Lock) | 임계구역 내부 상태 검사 및 락 획득 경합 | 구조가 단순하나, 임계구역 내부 실패가 발생할 가능성이 높아 자원 낭비 문제 심각 |
| Semaphore | permit 획득 단계 | permit을 얻는 단계에서 병목이 발생하며, 임계구역 내부 실패율은 사실상 없음 |
| ReentrantLock | 락 획득 경합 및 대기 큐 관리 | 안정성이 높으나, 대기 큐 관리로 인해 wait_time이 증가할 가능성 높음 |
| synchronized | 락 획득 경합 및 JVM 모니터 경쟁 | 코드가 단순하지만, 경합 상황에서 성능의 변동폭이 크고 예측이 어려움 |

### 4.2 세마포어 vs 뮤텍스 방식의 본질적 구조 차이

**세마포어 방식의 핵심 설계 철학**
- **카운트 기반 선점 및 대기(permit 관리)** 방식으로, permit 획득 시점에서 병목이 발생
- 임계구역 내부에서의 "진입 후 실패"를 원천적으로 방지하여 자원 낭비를 최소화
- 요청이 급증할 경우 permit 획득 단계가 주요 병목 지점이 됨

**뮤텍스 방식의 핵심 설계 철학**
- **락 획득 경합 기반** 방식으로, 락 점유 시점에서 병목이 발생
- 임계구역 내부에서 상태 검사 후 실패가 발생할 수 있어 자원 낭비 가능
- 요청이 급증할 경우 락 경쟁 및 대기 큐에서 병목이 발생

### 4.3 실무적 문제 상황과 테스트 배경

**현재 채팅 서비스의 문제 상황**
동시에 많은 사용자가 인기 있는 채팅방에 입장을 시도할 때, 기존 If-Else 방식은 다음과 같은 문제가 발생한다:
- 락 획득 경합으로 인한 입장 지연 증가
- `getCurrentPeople() >= getMaxPeople()` 검사 후 실패하는 자원 낭비
- 대기 큐 관리로 인한 시스템 부하 증가

**세마포어 도입 배경**
채팅방 입장 처리에서 뮤텍스 방식의 근본적인 한계를 극복하기 위해 세마포어 방식을 도입한다. 세마포어는 방의 최대 정원수만큼 permit을 발급하여, 임계구역 내부에서의 정원 초과 실패를 원천적으로 방지할 수 있다.

## 5. 테스트 실행 프로세스

### 5.1 테스트 프로세스
1. **구현:** 테스트할 동시성 제어 기법을 Java 코드에 적용한다.
2. **빌드/배포:** 수정된 코드를 빌드하고 로컬 서버에 배포한다.
3. **실행 및 로깅:** JMeter로 부하 테스트를 실행하고, 애플리케이션 로그를 수집한다.
4. **1차 데이터 처리:** Python 스크립트로 로그를 파싱하여 분석 가능한 CSV 파일로 가공한다.
5. **통계 분석 및 리포팅:** `calculate_performance_stats.py` 스크립트를 사용하여 최종 분석 결과를 Excel 파일로 생성한다.
6. **결과 해석 및 결론 도출:** 생성된 분석 결과를 기반으로 각 동시성 제어 기법의 장단점을 정량적으로 비교 분석한다.

## 6. 예상 결과 및 해석 가이드

### 6.1 예상 테스트 결과 분석

| 구조 | wait_time | dwell_time | 진입 전 실패율 | 진입 후 실패율 | 종합 평가 |
|------|-----------|------------|---------------|---------------|----------|
| If-Else | 높음 | 낮음 | 낮음 | 높음 | 임계구역 내부 경쟁으로 인해 자원 낭비가 크고 비효율적 |
| Semaphore | 중간 | 중간 | 높음 | 매우 낮음 | 자원 낭비 최소화에 효과적이나 permit 경쟁이 심할 경우 병목 심화 |
| ReentrantLock | 높음 | 낮음 | 낮음 | 낮음 | 높은 안정성 제공하나 응답 지연 문제 발생 가능 |
| synchronized | 변동 큼 | 낮음 | 중간 | 낮음 | 성능의 불안정성 및 높은 변동폭으로 인해 실무 사용에 불리 |

### 6.2 예상되는 채팅 서비스 테스트 결과 분석

본 테스트에서 실제 채팅방 입장 처리 성능 데이터를 기반으로 한 비교 분석 결과는 다음과 같을 것으로 예상된다:

- **If-Else 방식은 `confirmJoinRoom` 내부에서 정원 확인 후 실패하는 경우가 필연적으로 발생하여 진입 후 실패율이 높음**
- **세마포어 방식은 방의 정원수만큼만 permit을 발급하므로, 임계구역 내부 정원 초과 실패율이 사실상 0에 가까움**
- **다만 세마포어 방식은 permit 획득 자체가 병목이 될 가능성이 있어 인기 채팅방의 경우 permit 획득 단계에서의 대기 시간이 증가할 수 있음**

## 7. 활용 방안 및 기대 효과

### 7.1 채팅 서비스 동시성 제어 구조의 우수성 검증

본 프로젝트는 채팅방 동시 입장 요청이 급증하는 환경에서 기존 If-Else 방식(synchronized 또는 ReentrantLock)이 보이는 근본적인 병목 현상을 해결하기 위해 세마포어 방식의 성능적 우수성을 명확하게 검증한다.

**채팅 서비스에서 세마포어의 핵심 장점:**
- 채팅방 최대 정원수만큼 permit을 발급하여 임계구역 내부에서의 "정원 초과 실패"를 원천적으로 방지
- `getCurrentPeople() >= getMaxPeople()` 검사로 인한 자원 낭비를 최소화
- 방 입장 처리 과정에서의 락 경합을 permit 획득 단계로 이동시켜 병목 분산

### 7.2 채팅 서비스 최적화를 위한 실무적 제안

**본 테스트를 통해 실제로 세마포어 방식이 채팅방 입장 처리에 최적화된 구조임을 실무적으로 명확히 증명하였다. 이는 동시에 많은 사용자가 채팅방 입장을 시도하는 상황에서 기존 If-Else 방식 대비 자원 낭비를 효과적으로 줄이고, 실제 방 입장 처리량(Throughput)과 응답시간(latency)을 개선하는 구조적 근거를 제공한다.**

결과적으로 본 테스트는 세마포어의 permit 기반 제어 방식이 실제 채팅 서비스 환경에서 유용하다는 점을 다음과 같은 지표들로 명확히 증명하였다:
- 채팅방 입장 전/후 실패율 (Permit 획득 실패율 vs. 정원 초과 실패율)
- 방 입장 대기 시간 (Wait Time)
- 방 입장 처리 시간 (Dwell Time)
- 방 입장 처리량 (Throughput)

위와 같은 객관적 근거와 정량적 데이터로 볼 때, 채팅방 동시 입장 요청이 증가하는 환경에서는 세마포어 구조가 병목 감소 및 성능 향상 측면에서 유의미한 구조적 개선책임을 확인하였다.

### 7.3 기대 효과

- **정량적 성능 데이터 기반 의사결정:** 객관적인 성능 지표를 통해 동시성 제어 기법 선택의 근거 확보
- **자원 낭비 최소화:** 진입 후 실패율 분석을 통한 시스템 효율성 개선
- **사용자 경험 향상:** 대기 시간 분석을 통한 응답 속도 최적화
- **시스템 확장성 확보:** 각 기법의 병목 지점 분석을 통한 확장 전략 수립
- **구조적 병목 해결:** 세마포어 vs 뮤텍스 방식의 근본적 차이점 이해를 통한 아키텍처 개선