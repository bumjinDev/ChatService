# 성능 분석 지표 계산 스크립트 요구사항 (v1.9)

## 1. 개요 (Overview)

- **목표:** 전처리된 성능 테스트 결과(`clean_*.csv`)를 입력받아, 시각화 및 리포팅에 필요한 모든 통계 지표를 계산하고 그 결과를 구조화된 데이터 파일(Excel)로 저장하는 Python 스크립트를 개발한다.
- **스크립트명:** `calculate_performance_stats.py`
- **출력 위치:** 스크립트 실행 위치에 `performance_reports` 디렉토리를 생성하고, 그 안에 결과물을 저장한다.

---

## 2. 입력 데이터 및 라이브러리

### 2.1. 입력 데이터 (Input Data)
- **파일명:** `clean_five_events_performance_all_rooms.csv` 포맷을 따르는 파일
- **역할:** 각 스레드의 5개 핵심 이벤트(WAITING_START, CRITICAL_ENTER 등)에 대한 모든 원시 측정값을 담고 있는 전처리된 데이터입니다. 이 파일을 기반으로 모든 통계 지표를 계산합니다.

### 2.2. 라이브러리 (Libraries)
- **pandas:**
  - **역할:** CSV 파일을 데이터프레임으로 읽어오고, 데이터를 필터링, 그룹화하며, 모든 통계 계산(평균, 중앙값 등)을 수행하는 핵심 분석 라이브러리입니다.
- **openpyxl:**
  - **역할:** `pandas`가 계산된 데이터프레임을 Excel(`.xlsx`) 파일 형식으로 저장하기 위해 내부적으로 사용하는 라이브러리입니다.

---

## 3. 핵심 요구사항: 지표 계산

입력된 각 CSV 파일에 대해 다음의 **전처리**와 **통계 집계** 과정을 수행한다.

### 3.1. 데이터 분류 및 시간 계산
1. **데이터 분류:** 원본 데이터를 **(a) 최종_성공**, **(b) 진입_실패**, **(c) 정원초과_실패** 3개 그룹으로 필터링한다.
2. **시간 계산:**
   - **(a) 최종_성공 그룹:** '대기 시간(ms)'과 '임계 영역 실행 시간(ms)' 컬럼을 계산한다.
   - **(c) 정원초과_실패 그룹:** '대기 시간(ms)'과 '실패 처리 시간(ms)' (임계 영역 실행 시간) 컬럼을 계산한다.
   - *(b) 진입_실패 그룹은 진입 이전의 실패이므로 별도의 시간 계산이 필요 없다.*

### 3.2. 통계 집계
전처리된 데이터를 다음 관점으로 집계하여, 각각 별도의 Excel 시트에 저장할 데이터를 생성한다.

**1. 전체 통합 분석 (Overall Analysis):**
- **요약:** 3개 그룹으로 나누어 각각의 요청 수와 전체 대비 비율을 계산한다. (*`Overall_Summary` 시트용*)
- **성공 성능:** '최종_성공' 그룹의 '대기 시간'과 '임계 영역 실행 시간'에 대한 통계(평균, 중앙값, max)를 계산한다. (*`Overall_Success_Stats` 시트용*)
- **실패 처리 성능:** '정원초과_실패' 그룹의 '대기 시간'과 '실패 처리 시간'에 대한 통계(평균, 중앙값, max)를 계산한다. (*`Overall_Capacity_Failed_Stats` 시트용*)

**2. 방별 비교 분석 (Per-Room Analysis):**
- `roomNumber`를 기준으로 데이터를 그룹화하여, 각 방의 요청 수, 성공률, 실패율(정원초과, 진입실패), 각 결과 유형별 평균 시간 지표를 계산한다. (*`Per_Room_Stats` 시트용*)

**3. 방별 부하 누적 추이 분석 (Per-Room Bin Analysis):**
- 각 방(`roomNumber`) 내에서 `bin` 기준으로 그룹화하여, 방별 구간별 모든 성능 지표를 계산한다. (*`Per_Bin_Stats` 시트용*)

---

## 4. 출력 데이터 명세

- **출력 파일 형식:** **Excel (.xlsx)**
- **파일명:** 입력 CSV 파일명에 기반하여 `{label}_stats.xlsx` 형식으로 생성한다.

### 4.1. Sheet 1: `Overall_Summary`
**목적:** 전체 요청에 대한 결과를 요약하여 성공, 실패 유형별 분포를 한눈에 파악합니다.
**계산 방식:** 3개 데이터 그룹(성공, 진입실패, 정원초과실패)의 요청 수를 집계하고 전체 대비 비율을 계산합니다.

| 컬럼명 | 데이터 타입 | 설명 | 계산식 |
|--------|-------------|------|--------|
| Category | Text | 결과의 분류입니다. ('Total Requests', 'Success', 'Entry Failed (Lock, etc)', 'Capacity Failed') | 요청 결과 분류 카테고리 |
| Count | Integer | 각 분류에 해당하는 요청의 총 개수입니다. | 전체 요청 수, 성공한 요청 수, 임계영역 진입 실패 요청 수, 정원초과 실패 요청 수 |
| Percentage (%) | Float | 전체 요청 수(Total Requests) 대비 각 분류의 비율입니다. | (각 분류 요청 수 / 전체 요청 수) * 100 |

#### 예시 데이터
| Category | Count | Percentage (%) |
|----------|-------|----------------|
| Total Requests | 20000 | 100.0 |
| Success | 10000 | 50.0 |
| Entry Failed (Lock, etc) | 0 | 0.0 |
| Capacity Failed | 10000 | 50.0 |

### 4.2. Sheet 2: `Overall_Success_Stats`
**목적:** 성공한 모든 요청의 핵심 성능 지표에 대한 상세 통계치를 제공하여 전반적인 성능을 평가합니다.
**계산 방식:** 성공 그룹의 대기시간과 임계영역 실행시간에 대해 평균, 중앙값, 최댓값을 계산합니다.

| 컬럼명 | 데이터 타입 | 설명 | 계산식 |
|--------|-------------|------|--------|
| Metric | Text | 측정 대상 성능 지표입니다. ('Wait Time', 'Dwell Time (Critical Section)') | 성능 측정 지표 분류 |
| Statistic | Text | 적용된 통계치입니다. ('Mean', 'Median', 'Max') | 통계 분석 방법 분류 |
| Value (ms) | Float | 해당 통계치의 계산 결과값입니다. (단위: 밀리초) | 대기시간 = (임계영역 실제 진입 시점 - 임계영역 진입 시도 시점), 임계영역 점유시간 = (임계영역 종료 시점 - 임계영역 실제 진입 시점)의 평균, 중앙값, 최댓값 |

#### 예시 데이터
| Metric | Statistic | Value (ms) |
|--------|-----------|------------|
| Wait Time | Mean | 15.123 |
| Wait Time | Median | 12.456 |
| Wait Time | Max | 102.345 |
| Dwell Time (Critical Section) | Mean | 2.012 |
| Dwell Time (Critical Section) | Median | 1.987 |
| Dwell Time (Critical Section) | Max | 5.111 |

### 4.3. Sheet 3: `Overall_Capacity_Failed_Stats`
**목적:** 정원 초과로 실패한 요청들의 성능 특성을 분석하여 실패 과정에서의 부하를 파악합니다.
**계산 방식:** 정원초과 실패 그룹의 대기시간과 실패처리시간에 대해 평균, 중앙값, 최댓값을 계산합니다.

| 컬럼명 | 데이터 타입 | 설명 | 계산식 |
|--------|-------------|------|--------|
| Metric | Text | 측정 대상 성능 지표입니다. ('Wait Time', 'Fail Processing Time') | 성능 측정 지표 분류 |
| Statistic | Text | 적용된 통계치입니다. ('Mean', 'Median', 'Max') | 통계 분석 방법 분류 |
| Value (ms) | Float | 해당 통계치의 계산 결과값입니다. (단위: 밀리초) | 대기시간 = (임계영역 실제 진입 시점 - 임계영역 진입 시도 시점), 실패처리시간 = (실패 처리 완료 시점 - 임계영역 실제 진입 시점)의 평균, 중앙값, 최댓값 |

#### 예시 데이터
| Metric | Statistic | Value (ms) |
|--------|-----------|------------|
| Wait Time | Mean | 20.456 |
| Wait Time | Median | 18.123 |
| Wait Time | Max | 150.765 |
| Fail Processing Time | Mean | 0.532 |
| Fail Processing Time | Median | 0.499 |
| Fail Processing Time | Max | 1.234 |

### 4.4. Sheet 4: `Per_Room_Stats`
**목적:** 각 방별로 성공, 실패 분포와 결과 유형별 성능을 종합적으로 비교하여 특정 방의 문제점을 식별합니다.
**계산 방식:** roomNumber로 그룹화하여 각 방의 요청수, 성공/실패 비율, 결과 유형별 평균 시간 지표를 집계합니다.

| 컬럼명 | 데이터 타입 | 설명 | 계산식 |
|--------|-------------|------|--------|
| roomNumber | Integer | 방을 식별하는 고유 번호입니다. | 로그에서 추출된 방 식별 번호 |
| total_requests | Integer | 해당 방에 들어온 총 요청 수입니다. | 해당 방에 대한 전체 입장 시도 요청 수 |
| success_count | Integer | 해당 방에서 성공한 총 요청 수입니다. | 해당 방에 성공적으로 입장한 요청 수 |
| success_rate(%) | Float | 해당 방의 성공률입니다. | (성공적으로 입장한 요청 수 / 전체 입장 시도 요청 수) * 100 |
| capacity_failed_count | Integer | 해당 방에서 정원 초과로 실패한 요청 수입니다. | 해당 방에서 방 정원이 가득 차서 실패한 요청 수 |
| capacity_failed_rate(%) | Float | 해당 방의 정원 초과 실패율입니다. | (정원 초과로 실패한 요청 수 / 전체 입장 시도 요청 수) * 100 |
| entry_failed_count | Integer | 해당 방에서 임계 영역에 진입하지 못하고 실패한 요청 수입니다. | 해당 방에서 임계영역 진입 자체에 실패한 요청 수 |
| entry_failed_rate(%) | Float | 해당 방의 진입 실패율입니다. | (임계영역 진입 실패한 요청 수 / 전체 입장 시도 요청 수) * 100 |
| success_avg_wait_time(ms) | Float | 해당 방의 성공한 요청들의 평균 대기 시간입니다. | 해당 방에서 성공한 요청들의 평균 (임계영역 실제 진입 시점 - 임계영역 진입 시도 시점) |
| success_avg_dwell_time(ms) | Float | 해당 방의 성공한 요청들의 평균 임계 영역 실행 시간입니다. | 해당 방에서 성공한 요청들의 평균 (임계영역 종료 시점 - 임계영역 실제 진입 시점) |
| capacity_failed_avg_wait_time(ms) | Float | 해당 방의 정원 초과로 실패한 요청들의 평균 대기 시간입니다. | 해당 방에서 정원초과 실패한 요청들의 평균 (임계영역 실제 진입 시점 - 임계영역 진입 시도 시점) |
| capacity_failed_avg_fail_processing_time(ms) | Float | 해당 방의 정원 초과로 실패한 요청들의 평균 실패 처리 시간입니다. | 해당 방에서 정원초과 실패한 요청들의 평균 (실패 처리 완료 시점 - 임계영역 실제 진입 시점) |

#### 예시 데이터
| roomNumber | total_requests | success_count | success_rate(%) | capacity_failed_count | capacity_failed_rate(%) | entry_failed_count | entry_failed_rate(%) | success_avg_wait_time(ms) | success_avg_dwell_time(ms) | capacity_failed_avg_wait_time(ms) | capacity_failed_avg_fail_processing_time(ms) |
|------------|----------------|---------------|-----------------|----------------------|------------------------|-------------------|---------------------|---------------------------|----------------------------|-----------------------------------|---------------------------------------------|
| 1 | 2000 | 1000 | 50.0 | 1000 | 50.0 | 0 | 0.0 | 14.5 | 2.1 | 20.3 | 0.8 |
| 2 | 2000 | 1000 | 50.0 | 1000 | 50.0 | 0 | 0.0 | 14.8 | 2.0 | 20.1 | 0.7 |
| 10 | 2000 | 1000 | 50.0 | 1000 | 50.0 | 0 | 0.0 | 15.2 | 2.1 | 20.5 | 0.9 |

### 4.5. Sheet 5: `Per_Bin_Stats`
**목적:** 각 방마다 시간의 흐름에 따른 성능 변화 추이를 분석하여, 부하 누적이 시스템에 미치는 영향을 파악합니다.
**계산 방식:** roomNumber와 bin으로 그룹화하여 방별 구간별 요청수, 성공/실패 비율, 결과 유형별 평균 시간 지표를 집계합니다.

| 컬럼명 | 데이터 타입 | 설명 | 계산식 |
|--------|-------------|------|--------|
| roomNumber | Integer | 통계가 집계된 방의 고유 번호입니다. | 로그에서 추출된 방 식별 번호 |
| bin | Integer | 요청을 순서대로 나눈 구간을 식별하는 번호입니다. | 로그에서 추출된 시간 구간 식별 번호 |
| total_requests | Integer | 해당 방, 해당 구간에 들어온 총 요청 수입니다. | 해당 방, 해당 시간구간에 대한 전체 입장 시도 요청 수 |
| success_count | Integer | 해당 방, 해당 구간에서 성공한 총 요청 수입니다. | 해당 방, 해당 시간구간에서 성공적으로 입장한 요청 수 |
| success_rate(%) | Float | 해당 방, 해당 구간의 성공률입니다. | (성공적으로 입장한 요청 수 / 전체 입장 시도 요청 수) * 100 |
| capacity_failed_count | Integer | 해당 방, 해당 구간에서 정원 초과로 실패한 요청 수입니다. | 해당 방, 해당 시간구간에서 방 정원이 가득 차서 실패한 요청 수 |
| capacity_failed_rate(%) | Float | 해당 방, 해당 구간의 정원 초과 실패율입니다. | (정원 초과로 실패한 요청 수 / 전체 입장 시도 요청 수) * 100 |
| entry_failed_count | Integer | 해당 방, 해당 구간에서 임계 영역에 진입하지 못하고 실패한 요청 수입니다. | 해당 방, 해당 시간구간에서 임계영역 진입 자체에 실패한 요청 수 |
| entry_failed_rate(%) | Float | 해당 방, 해당 구간의 진입 실패율입니다. | (임계영역 진입 실패한 요청 수 / 전체 입장 시도 요청 수) * 100 |
| success_avg_wait_time(ms) | Float | 해당 방, 해당 구간의 성공한 요청들의 평균 대기 시간입니다. | 해당 방, 해당 시간구간에서 성공한 요청들의 평균 (임계영역 실제 진입 시점 - 임계영역 진입 시도 시점) |
| success_avg_dwell_time(ms) | Float | 해당 방, 해당 구간의 성공한 요청들의 평균 임계 영역 실행 시간입니다. | 해당 방, 해당 시간구간에서 성공한 요청들의 평균 (임계영역 종료 시점 - 임계영역 실제 진입 시점) |
| capacity_failed_avg_wait_time(ms) | Float | 해당 방, 해당 구간의 정원 초과로 실패한 요청들의 평균 대기 시간입니다. | 해당 방, 해당 시간구간에서 정원초과 실패한 요청들의 평균 (임계영역 실제 진입 시점 - 임계영역 진입 시도 시점) |
| capacity_failed_avg_fail_processing_time(ms) | Float | 해당 방, 해당 구간의 정원 초과로 실패한 요청들의 평균 실패 처리 시간입니다. | 해당 방, 해당 시간구간에서 정원초과 실패한 요청들의 평균 (실패 처리 완료 시점 - 임계영역 실제 진입 시점) |

#### 예시 데이터
| roomNumber | bin | total_requests | success_count | success_rate(%) | capacity_failed_count | capacity_failed_rate(%) | entry_failed_count | entry_failed_rate(%) | success_avg_wait_time(ms) | success_avg_dwell_time(ms) | capacity_failed_avg_wait_time(ms) | capacity_failed_avg_fail_processing_time(ms) |
|------------|-----|----------------|---------------|-----------------|----------------------|------------------------|-------------------|---------------------|---------------------------|----------------------------|-----------------------------------|---------------------------------------------|
| 1 | 1 | 200 | 100 | 50.0 | 100 | 50.0 | 0 | 0.0 | 1.5 | 2.0 | 2.1 | 0.5 |
| 1 | 2 | 200 | 100 | 50.0 | 100 | 50.0 | 0 | 0.0 | 2.1 | 2.0 | 3.2 | 0.6 |
| 1 | 3 | 200 | 100 | 50.0 | 100 | 50.0 | 0 | 0.0 | 3.5 | 2.1 | 4.8 | 0.7 |
| 10 | 10 | 200 | 100 | 50.0 | 100 | 50.0 | 0 | 0.0 | 25.3 | 2.2 | 35.1 | 1.2 |

---

## 5. 스크립트 실행 방법

커맨드 라인 인자를 통해 실행한다.
- `--inputs`: 분석할 CSV 파일 경로들 (콤마로 구분).
- `--labels`: 각 CSV 파일에 해당하는 출력 레이블 (콤마로 구분).

```bash
python calculate_performance_stats.py \
    --inputs "clean_data/ReentrantLock.csv,clean_data/Synchronized.csv" \
    --labels "ReentrantLock,Synchronized"
```

---

## 6. 상세 계산식 정의

### 6.1. 데이터 로드 및 기본 전처리

```python
import pandas as pd

# 1. 원본 데이터 로드
try:
    df_total = pd.read_csv('clean_five_events_performance_all_rooms.csv')
except FileNotFoundError:
    print("오류: CSV 파일을 찾을 수 없습니다.")
    exit()

# 2. 시간 컬럼들을 datetime 객체로 변환
time_cols = ['waiting_start_time', 'critical_enter_time', 'critical_leave_time']
for col in time_cols:
    df_total[col] = pd.to_datetime(df_total[col], errors='coerce')
```

### 6.2. 데이터 분류 및 시간 컬럼 계산

```python
# 1. 비율 계산 함수 정의
def calculate_rate(count, total):
    return (count / total) * 100 if total > 0 else 0

# 2. 통계 계산 함수 정의
def get_stats(series):
    return {
        'Mean': series.mean(),
        'Median': series.median(),
        'Max': series.max()
    }

# 3. 데이터 그룹 3개 필터링
df_success = df_total[df_total['join_result'] == 'SUCCESS'].copy()
df_lock_failed = df_total[df_total['critical_enter_time'].isnull()].copy()
df_capacity_failed = df_total[df_total['join_result'] == 'FAIL_OVER_CAPACITY'].copy()

# 4. 성공 그룹의 시간차 컬럼 계산
df_success['wait_time_ms'] = (df_success['critical_enter_time'] - df_success['waiting_start_time']).dt.total_seconds() * 1000
df_success['dwell_time_ms'] = (df_success['critical_leave_time'] - df_success['critical_enter_time']).dt.total_seconds() * 1000

# 5. 정원초과 실패 그룹의 시간차 컬럼 계산
df_capacity_failed['wait_time_ms'] = (df_capacity_failed['critical_enter_time'] - df_capacity_failed['waiting_start_time']).dt.total_seconds() * 1000
df_capacity_failed['fail_processing_time_ms'] = (df_capacity_failed['critical_leave_time'] - df_capacity_failed['critical_enter_time']).dt.total_seconds() * 1000
```

### 6.3. Overall_Summary 시트 생성

```python
# 1. 각 그룹별 요청 수 계산
total_requests = len(df_total)
success_count = len(df_success)
lock_failed_count = len(df_lock_failed)
capacity_failed_count = len(df_capacity_failed)

# 2. 시트 데이터프레임 생성
summary_data = {
    'Category': [
        'Total Requests',
        'Success',
        'Entry Failed (Lock, etc)',
        'Capacity Failed'
    ],
    'Count': [
        total_requests,
        success_count,
        lock_failed_count,
        capacity_failed_count
    ],
    'Percentage (%)': [
        100.0,
        calculate_rate(success_count, total_requests),
        calculate_rate(lock_failed_count, total_requests),
        calculate_rate(capacity_failed_count, total_requests)
    ]
}
df_summary = pd.DataFrame(summary_data)
```

### 6.4. Overall_Success_Stats 시트 생성

```python
# 1. 통계 계산
wait_time_stats = get_stats(df_success['wait_time_ms'])
dwell_time_stats = get_stats(df_success['dwell_time_ms'])

# 2. 시트 데이터프레임 생성
success_stats_data = {
    'Metric': ['Wait Time'] * 3 + ['Dwell Time (Critical Section)'] * 3,
    'Statistic': ['Mean', 'Median', 'Max'] * 2,
    'Value (ms)': [
        wait_time_stats['Mean'], wait_time_stats['Median'], wait_time_stats['Max'],
        dwell_time_stats['Mean'], dwell_time_stats['Median'], dwell_time_stats['Max']
    ]
}
df_success_stats = pd.DataFrame(success_stats_data)
```

### 6.5. Overall_Capacity_Failed_Stats 시트 생성

```python
# 1. 통계 계산
capacity_wait_stats = get_stats(df_capacity_failed['wait_time_ms'])
fail_proc_stats = get_stats(df_capacity_failed['fail_processing_time_ms'])

# 2. 시트 데이터프레임 생성
capacity_failed_stats_data = {
    'Metric': ['Wait Time'] * 3 + ['Fail Processing Time'] * 3,
    'Statistic': ['Mean', 'Median', 'Max'] * 2,
    'Value (ms)': [
        capacity_wait_stats['Mean'], capacity_wait_stats['Median'], capacity_wait_stats['Max'],
        fail_proc_stats['Mean'], fail_proc_stats['Median'], fail_proc_stats['Max']
    ]
}
df_capacity_failed_stats = pd.DataFrame(capacity_failed_stats_data)
```

### 6.6. Per_Room_Stats 시트 생성

```python
# 1. 방별 요청 수 계산
total_per_room = df_total.groupby('roomNumber').size().rename('total_requests')
success_per_room = df_success.groupby('roomNumber').size().rename('success_count')
capacity_failed_per_room = df_capacity_failed.groupby('roomNumber').size().rename('capacity_failed_count')
entry_failed_per_room = df_lock_failed.groupby('roomNumber').size().rename('entry_failed_count')

# 2. 방별 성공 요청 평균 시간 계산
success_avg_wait_per_room = df_success.groupby('roomNumber')['wait_time_ms'].mean().rename('success_avg_wait_time(ms)')
success_avg_dwell_per_room = df_success.groupby('roomNumber')['dwell_time_ms'].mean().rename('success_avg_dwell_time(ms)')

# 3. 방별 정원초과 실패 요청 평균 시간 계산
capacity_failed_avg_wait_per_room = df_capacity_failed.groupby('roomNumber')['wait_time_ms'].mean().rename('capacity_failed_avg_wait_time(ms)')
capacity_failed_avg_fail_proc_per_room = df_capacity_failed.groupby('roomNumber')['fail_processing_time_ms'].mean().rename('capacity_failed_avg_fail_processing_time(ms)')

# 4. 데이터 병합
df_per_room_stats = pd.concat([
    total_per_room, 
    success_per_room, 
    capacity_failed_per_room,
    entry_failed_per_room,
    success_avg_wait_per_room, 
    success_avg_dwell_per_room,
    capacity_failed_avg_wait_per_room,
    capacity_failed_avg_fail_proc_per_room
], axis=1)

# 5. NaN 값 처리 및 비율 계산
df_per_room_stats = df_per_room_stats.fillna(0)
df_per_room_stats['success_rate(%)'] = calculate_rate(df_per_room_stats['success_count'], df_per_room_stats['total_requests'])
df_per_room_stats['capacity_failed_rate(%)'] = calculate_rate(df_per_room_stats['capacity_failed_count'], df_per_room_stats['total_requests'])
df_per_room_stats['entry_failed_rate(%)'] = calculate_rate(df_per_room_stats['entry_failed_count'], df_per_room_stats['total_requests'])

# 6. 컬럼 순서 정리 및 인덱스 리셋
df_per_room_stats = df_per_room_stats.reset_index()
final_cols = [
    'roomNumber', 
    'total_requests', 
    'success_count', 
    'success_rate(%)', 
    'capacity_failed_count', 
    'capacity_failed_rate(%)', 
    'entry_failed_count', 
    'entry_failed_rate(%)', 
    'success_avg_wait_time(ms)', 
    'success_avg_dwell_time(ms)',
    'capacity_failed_avg_wait_time(ms)', 
    'capacity_failed_avg_fail_processing_time(ms)'
]
df_per_room_stats = df_per_room_stats[final_cols]
```

### 6.7. Per_Bin_Stats 시트 생성

```python
# 1. roomNumber와 bin 기준으로 전체/성공/실패 요청 수 계산
total_per_room_bin = df_total.groupby(['roomNumber', 'bin']).size().rename('total_requests')
success_per_room_bin = df_success.groupby(['roomNumber', 'bin']).size().rename('success_count')
capacity_failed_per_room_bin = df_capacity_failed.groupby(['roomNumber', 'bin']).size().rename('capacity_failed_count')
entry_failed_per_room_bin = df_lock_failed.groupby(['roomNumber', 'bin']).size().rename('entry_failed_count')

# 2. roomNumber와 bin 기준으로 성공 요청 평균 시간 계산
success_avg_wait_per_room_bin = df_success.groupby(['roomNumber', 'bin'])['wait_time_ms'].mean().rename('success_avg_wait_time(ms)')
success_avg_dwell_per_room_bin = df_success.groupby(['roomNumber', 'bin'])['dwell_time_ms'].mean().rename('success_avg_dwell_time(ms)')

# 3. roomNumber와 bin 기준으로 정원초과 실패 요청 평균 시간 계산
capacity_failed_avg_wait_per_room_bin = df_capacity_failed.groupby(['roomNumber', 'bin'])['wait_time_ms'].mean().rename('capacity_failed_avg_wait_time(ms)')
capacity_failed_avg_fail_proc_per_room_bin = df_capacity_failed.groupby(['roomNumber', 'bin'])['fail_processing_time_ms'].mean().rename('capacity_failed_avg_fail_processing_time(ms)')

# 4. 모든 데이터 병합
df_per_bin_stats = pd.concat([
    total_per_room_bin,
    success_per_room_bin,
    capacity_failed_per_room_bin,
    entry_failed_per_room_bin,
    success_avg_wait_per_room_bin,
    success_avg_dwell_per_room_bin,
    capacity_failed_avg_wait_per_room_bin,
    capacity_failed_avg_fail_proc_per_room_bin
], axis=1)

# 5. NaN 값 처리 및 비율 계산
df_per_bin_stats = df_per_bin_stats.fillna(0)
df_per_bin_stats['success_rate(%)'] = calculate_rate(df_per_bin_stats['success_count'], df_per_bin_stats['total_requests'])
df_per_bin_stats['capacity_failed_rate(%)'] = calculate_rate(df_per_bin_stats['capacity_failed_count'], df_per_bin_stats['total_requests'])
df_per_bin_stats['entry_failed_rate(%)'] = calculate_rate(df_per_bin_stats['entry_failed_count'], df_per_bin_stats['total_requests'])

# 6. 컬럼 순서 정리 및 인덱스 리셋
df_per_bin_stats = df_per_bin_stats.reset_index()
final_cols = [
    'roomNumber', 
    'bin',
    'total_requests', 
    'success_count', 
    'success_rate(%)', 
    'capacity_failed_count', 
    'capacity_failed_rate(%)', 
    'entry_failed_count', 
    'entry_failed_rate(%)', 
    'success_avg_wait_time(ms)', 
    'success_avg_dwell_time(ms)',
    'capacity_failed_avg_wait_time(ms)', 
    'capacity_failed_avg_fail_processing_time(ms)'
]
df_per_bin_stats = df_per_bin_stats[final_cols]
```

### 6.8. Excel 파일 저장

```python
# 1. 출력 디렉토리 생성
import os
output_dir = 'performance_reports'
os.makedirs(output_dir, exist_ok=True)

# 2. Excel 파일로 저장 (label은 커맨드라인에서 입력받은 값)
output_file = os.path.join(output_dir, f'{label}_stats.xlsx')
with pd.ExcelWriter(output_file, engine='openpyxl') as writer:
    df_summary.to_excel(writer, sheet_name='Overall_Summary', index=False)
    df_success_stats.to_excel(writer, sheet_name='Overall_Success_Stats', index=False)
    df_capacity_failed_stats.to_excel(writer, sheet_name='Overall_Capacity_Failed_Stats', index=False)
    df_per_room_stats.to_excel(writer, sheet_name='Per_Room_Stats', index=False)
    df_per_bin_stats.to_excel(writer, sheet_name='Per_Bin_Stats', index=False)

print(f"분석 결과가 {output_file}에 저장되었습니다.")
```

---