✅ 세마포어 기반 채팅방 입장 제어 설계 백서
======================================

🎯 설계 배경 및 문제 인식
--------------------------
채팅방 시스템에서 여러 사용자가 동시에 동일한 방에 입장 요청을 보내는 상황은 필연적이다. 
하지만 이 요청들은 모두 비동기적으로 서버에 도달하며, 
전통적인 방식(단순한 DB 인원 수 조회 및 삽입)으로는 
인원 초과, 중복 입장, 상태 정합성 붕괴 같은 문제가 발생할 수 있다.

특히, 다음과 같은 상황이 실전에서 자주 관찰되었다:

- 동시에 입장 요청이 몰릴 경우, DB 인원 수 갱신이 반영되기 전 추가 입장이 발생함
- 방 입장 페이지는 반환됐지만 실제 WebSocket 연결이 이루어지지 않음
- 연결이 실패했음에도 불구하고 자원 점유가 반영되어 인원 수가 누적됨

이러한 상황은 단순한 예외 케이스가 아니라, 비동기 입장 구조에서 구조적으로 발생할 수밖에 없는 문제이다.

🧩 문제의 구조적 원인
--------------------------
문제 | 원인 | 실전 영향
----|------|----------
인원 수 초과 | DB 동시성 미보장 / 요청 타이밍 간극 | 실 사용자보다 더 많은 입장이 허용됨
중복 입장 | WebSocket 세션 맺기 전 자원 점유 | 입장 실패자도 인원으로 카운트됨
유실된 세션 | 방 페이지 반환 후 연결 실패 | 자원만 점유하고 실입장 없음

🧠 설계 전략 개요
--------------------------
1. 입장 판단과 자원 점유를 분리한다.
2. 자원 점유는 WebSocket 연결 시점에서만 허용한다.
3. 입장 요청 시점에는 "자원 보호 장치"만 설정한다.
4. 전체 인원 수 계산은 세마포어 permit 잔여 수 + DB 기준 인원 수를 기반으로 확인한다.

Java의 Semaphore 객체를 활용해 동시 입장 수를 제어하고, 각 방 번호 별로 permit을 할당함.

🧱 핵심 구성 요소 및 책임
--------------------------
컴포넌트 | 책임 요약
---------|-----------
RoomJoinService | 요청 식별, 대기열 등록, 신규 방에 한해 세마포어 등록 및 입장 가능 여부 계산
WebSocketHandler | 실제 입장 처리, permit 획득, 연결 성공 시 timestamp 갱신
SemaphoreRegistry | 자원 제어 책임 전담, TTL 관리 포함, permit 정보 제공
RoomQueueCleanerScheduler | 일정 주기마다 유휴 세마포어 정리 (TTL 기준)

🔁 흐름별 상세 설계
--------------------------

[1] 신규 방 입장 요청
1. RoomJoinService에서 DB 조회 → 테이블 없음
2. inMemory 대기열에서 존재 확인
3. 존재하면 SemaphoreRegistry.register(roomId, maxPeople)
4. permit 상태 확인 → currentPermits + dbPeopleCount + 1 > maxPeople 여부 판단
5. 조건 만족 시 입장 허용 및 queue 등록

[2] 기존 방 입장 요청
1. DB에서 현재 인원 수 조회
2. getAvailablePermits 호출
3. availablePermits + currentPeople + 1 계산
4. 최대 인원 초과 시 예외
5. 입장 허용 시 queue 등록

[3] 실제 입장 시점 (WebSocket)
1. 클라이언트가 WebSocket 요청
2. tryAcquire(roomId) 호출
3. 성공 시 연결 성립 + resetTimestamp()
4. 실패 시 연결 종료

[4] 세마포어 TTL 정리
1. Scheduler가 주기 실행
2. createdAtMap 기준으로 TTL 초과 여부 판단
3. 초과된 방은 unregister(roomId) 처리

🧼 실전 고려 사항
--------------------------
- RoomJoinService는 실제 세션 연결을 하지 않는다.
- 세마포어 등록은 신규 요청에만 수행
- TTL은 고정 2분이며 향후 정책화 예정
- 연결 성공 시 resetTimestamp() 호출로 TTL 연장 가능
- createdAtMap 존재 여부 자체가 상태 표현 수단
  → WebSocket 성공 시 제거 → TTL 정리 대상 제외
- 이 구조는 SRP에 부합하고, 플래그 없이 상태 전이를 구조로 표현함

📌 결론
--------------------------
- 요청 분류 → RoomJoinService
- 자원 등록/보호/점유 → SemaphoreRegistry + WebSocketHandler
- TTL 판단 및 정리 → RoomQueueCleanerScheduler

장점:
- ✅ 동시 요청 경합 해소
- ✅ 보호와 점유 시점 분리
- ✅ TTL로 자원 누수 방지
- ✅ 구조 분리로 확장성 확보

이 설계는 비동기 환경에서 상태 정합성을 보장하기 위한 실전 대비형 구조이다.


==========

# ✅ 세마포어 기반 사용자 연결 흐름 및 동기화 책임 분리 설계 문서

---

## 🎯 문서 목적

이 문서는 채팅방 입장 구조 설계 시 세마포어를 이용한 자원 점유와 사용자 연결 상태 추적 간의 동기화 책임 범위를 명확히 정의하기 위한 설계 문서이다. 

단순한 기술 설명을 넘어, 동기화 여부 판단의 근거, 자원과 추적 로직의 분리 타당성, WebSocket 연결 실패 시 자원 회수 전략까지 모두 구조적으로 정리한다. 또한 추적 로직 자체를 TTL 기반으로 어떻게 설계할 것인지, 세마포어 permit 점유와 실제 사용자 식별 추적 로직이 분리되어 있음에도 불구하고 어떻게 최종 정합성에 영향을 주지 않는지 분석적으로 설명한다.

---

## 🧩 문제 정의

### [문제 1] WebSocket 연결 중 실패를 어떤 메서드에서 감지할 수 있는가?

> 클라이언트가 방 페이지는 열었지만, JS 모듈에서 WebSocket 연결 도중 실패할 경우 서버는 어떤 방식으로 자원 회수 타이밍을 감지할 수 있는가?

### [문제 2] WebSocket 시도조차 하지 못한 경우, 자원은 어떻게 회수할 것인가?

> JS 자체를 못 받아간 클라이언트의 경우, 서버는 연결 요청 자체를 수신하지 못하기 때문에 자원 회수를 위한 TTL 기반 구조가 필요하다.

또한, `tryAcquire()` 이후 사용자 별 연결 시간 추적을 위한 Map에 데이터를 저장할 때, 이 Map과 세마포어 간의 상태 변경이 동기화되어야 하는지 여부도 판단 기준이 요구된다.

---

## ⚙️ 전체 흐름 구성 및 세션 실패 감지 설계

### [1] `joinService`에서 `tryAcquire()` 호출 → 자원 점유

```java
boolean acquired = semaphoreRegistry.tryAcquire(roomId);
if (acquired) {
    userTrackerMap.put(userId, System.currentTimeMillis());
}
```

- `tryAcquire()`는 내부적으로 CAS(Compare-And-Swap) 기반의 원자 연산을 수행함
- 이 단계에서 이미 인원수 제한 자원은 충돌 없이 점유됨
- 이후의 사용자 추적 로직은 자원 상태에 영향을 주지 않으므로 별도 동기화 필요 없음
- `tryAcquire()` 성공 시에만 자원을 점유한 것으로 간주하며, 이로 인해 추적 로직이 시작될 자격이 생긴다. 실패한 요청에 대해선 별도의 기록이 필요 없다.

### [2] WebSocket 연결 시도 → 실패 감지 메서드

| 메서드 | 설명 |
|--------|------|
| `afterConnectionEstablished()` | WebSocket 연결 성공 시점 (자원 점유 확정) |
| `handleTransportError()` | 전송 중 예외 발생 시 호출됨 → 연결 실패 감지 |
| `afterConnectionClosed()` | 세션 종료 감지 (정상 or 예외 포함 가능) |

#### 예시:
```java
@Override
public void handleTransportError(WebSocketSession session, Throwable exception) {
    Integer roomId = (Integer) session.getAttributes().get("roomId");
    if (roomId != null) {
        semaphoreRegistry.release(roomId);
    }
}
```

이 구조는 자원 점유 → 실패 → 자원 회수라는 흐름을 WebSocket에서 전적으로 책임지게 하며, joinService와의 책임을 명확히 분리한다.

### [3] JS 수신 실패(접속 자체 실패) → 서버는 감지 불가

- 사용자가 방 페이지 자체를 받지 못했거나 브라우저 단에서 JS 모듈 실행조차 못한 경우
- 서버는 이 상태를 감지할 수 없으므로 TTL 기반 추적이 필요
- WebSocket 핸들러에 도달하지 못했기 때문에 `afterConnection*()` 계열의 콜백조차 발생하지 않음

---

## ⏱️ TTL 기반 자원 회수 설계

### 1. `SemaphoreRegistry` 내 자원 생성 시간 기록

```java
private final Map<Integer, Long> createdAtMap = new ConcurrentHashMap<>();
```

- 방 번호 → 생성된 시각(epoch ms) 저장
- WebSocket 연결 성공 시점에서 제거하여 TTL 회수 대상에서 제외
- 이 Map에 존재하는 상태는 "자원은 점유되었지만 WebSocket 연결은 확인되지 않은 상태"를 의미함

### 2. 스케줄러 기반 자원 회수 로직

```java
@Scheduled(fixedRate = 30000)
public void clearExpiredPermits() {
    long now = System.currentTimeMillis();
    for (var entry : createdAtMap.entrySet()) {
        if (now - entry.getValue() > TTL_LIMIT_MS) {
            semaphoreRegistry.release(entry.getKey());
            createdAtMap.remove(entry.getKey());
        }
    }
}
```

- 2분 기준 TTL (향후 정책 객체로 외부화 예정)
- WebSocket 연결이 성립되지 않은 방 번호만 남아 있음
- 스케줄러는 세마포어 내부 구조를 알 필요 없이 외부 타임맵만 순회함 → DIP 만족

### 3. 연결 성공 시 자원 확정 및 TTL 제거

```java
@Override
public void afterConnectionEstablished(WebSocketSession session) {
    Integer roomId = (Integer) session.getAttributes().get("roomId");
    if (roomId != null) {
        createdAtMap.remove(roomId);
    }
}
```

이 호출이 성공하면 자원 점유는 확정 상태로 전이되며, 더 이상 TTL 회수 대상이 아님을 의미한다.

---

## ✅ userMap(userId → timestamp)와 세마포어 간 동기화 여부

### 🎯 질문:
세마포어에서 `tryAcquire()` 성공 이후, userId를 별도 추적 맵에 넣는 건 동기화가 필요할까?

### ✅ 결론: **필요하지 않다**

| 이유 | 설명 |
|------|------|
| `tryAcquire()`는 CAS로 보호됨 | 자원 상태는 이미 안전하게 점유됨 |
| userMap은 자원 상태에 영향 없음 | 단순 메타데이터 추적 (유저 연결 실패 분석 등) |
| 동기화는 TTL 회수 시점에서만 주의 | `ConcurrentHashMap`으로 충돌 최소화 |

즉, 자원 상태 변경과 추적 정보 기록은 논리적으로 분리된 concern이며, 
두 연산이 동기화될 필요는 없다. 이 판단 기준은 실제 동시성 설계에서
불필요한 락 범위를 줄이는 핵심 기준이 된다.

이 설계는 단순 동기화 해제가 아니라, **동기화 경계를 명확히 선언하는 구조화된 설계 판단**으로, 고성능 처리를 지향하는 시스템에서 매우 중요하다.

---

## 📌 결론

- 자원 점유는 `joinService`에서 `tryAcquire()`로 선점하고, 이후 WebSocket 성공 시 확정됨
- 실패 시점은 서버에서 감지 가능 (`TransportError`, `ConnectionClosed`)
- JS 수신 실패 등 감지 불가능한 상태는 TTL 기반 회수 로직으로 보완됨
- 유저 ID 추적 로직은 자원 제어와 분리되므로, 구조적 동기화는 불필요

📌 이 구조는 동시성 충돌을 원천적으로 방지하고, 상태 정합성을 유지하면서도
불필요한 락을 최소화한 구조이며, 추후 메시지 큐 기반 확장에도 그대로 연동 가능하다.

또한 이 설계는 단순한 예외 처리가 아니라, 자원 상태 전이, 실패 감지, 관찰자 추적이라는 3계층의 상태 흐름을 의식적으로 구분하여 시스템 전체의 구조적 일관성과 확장성을 확보한다.