# ✅ 세마포어 기반 사용자 연결 흐름 및 동기화 책임 분리 설계 문서

---

## 🎯 문서 목적

이 문서는 채팅방 입장 구조 설계 시 세마포어를 이용한 자원 점유와 사용자 연결 상태 추적 간의 동기화 책임 범위를 명확히 정의하기 위한 설계 문서이다. 

단순한 기술 설명을 넘어, 동기화 여부 판단의 근거, 자원과 추적 로직의 분리 타당성, WebSocket 연결 실패 시 자원 회수 전략까지 모두 구조적으로 정리한다. 또한 추적 로직 자체를 TTL 기반으로 어떻게 설계할 것인지, 세마포어 permit 점유와 실제 사용자 식별 추적 로직이 분리되어 있음에도 불구하고 어떻게 최종 정합성에 영향을 주지 않는지 분석적으로 설명한다.

---

## 🧩 문제 정의

### [문제 1] WebSocket 연결 중 실패를 어떤 메서드에서 감지할 수 있는가?

> 클라이언트가 방 페이지는 열었지만, JS 모듈에서 WebSocket 연결 도중 실패할 경우 서버는 어떤 방식으로 자원 회수 타이밍을 감지할 수 있는가?

### [문제 2] WebSocket 시도조차 하지 못한 경우, 자원은 어떻게 회수할 것인가?

> JS 자체를 못 받아간 클라이언트의 경우, 서버는 연결 요청 자체를 수신하지 못하기 때문에 자원 회수를 위한 TTL 기반 구조가 필요하다.

또한, `tryAcquire()` 이후 사용자 별 연결 시간 추적을 위한 Map에 데이터를 저장할 때, 이 Map과 세마포어 간의 상태 변경이 동기화되어야 하는지 여부도 판단 기준이 요구된다.

---

## ⚙️ 전체 흐름 구성 및 세션 실패 감지 설계

### [1] `joinService`에서 `tryAcquire()` 호출 → 자원 점유

```java
boolean acquired = semaphoreRegistry.tryAcquire(roomId);
if (acquired) {
    userTrackerMap.put(userId, System.currentTimeMillis());
}
```

- `tryAcquire()`는 내부적으로 CAS(Compare-And-Swap) 기반의 원자 연산을 수행함
- 이 단계에서 이미 인원수 제한 자원은 충돌 없이 점유됨
- 이후의 사용자 추적 로직은 자원 상태에 영향을 주지 않으므로 별도 동기화 필요 없음
- `tryAcquire()` 성공 시에만 자원을 점유한 것으로 간주하며, 이로 인해 추적 로직이 시작될 자격이 생긴다. 실패한 요청에 대해선 별도의 기록이 필요 없다.

### [2] WebSocket 연결 시도 → 실패 감지 메서드

| 메서드 | 설명 |
|--------|------|
| `afterConnectionEstablished()` | WebSocket 연결 성공 시점 (자원 점유 확정) |
| `handleTransportError()` | 전송 중 예외 발생 시 호출됨 → 연결 실패 감지 |
| `afterConnectionClosed()` | 세션 종료 감지 (정상 or 예외 포함 가능) |

#### 예시:
```java
@Override
public void handleTransportError(WebSocketSession session, Throwable exception) {
    Integer roomId = (Integer) session.getAttributes().get("roomId");
    if (roomId != null) {
        semaphoreRegistry.release(roomId);
    }
}
```

이 구조는 자원 점유 → 실패 → 자원 회수라는 흐름을 WebSocket에서 전적으로 책임지게 하며, joinService와의 책임을 명확히 분리한다.

### [3] JS 수신 실패(접속 자체 실패) → 서버는 감지 불가

- 사용자가 방 페이지 자체를 받지 못했거나 브라우저 단에서 JS 모듈 실행조차 못한 경우
- 서버는 이 상태를 감지할 수 없으므로 TTL 기반 추적이 필요
- WebSocket 핸들러에 도달하지 못했기 때문에 `afterConnection*()` 계열의 콜백조차 발생하지 않음

---

## ⏱️ TTL 기반 자원 회수 설계

### 1. `SemaphoreRegistry` 내 자원 생성 시간 기록

```java
private final Map<Integer, Long> createdAtMap = new ConcurrentHashMap<>();
```

- 방 번호 → 생성된 시각(epoch ms) 저장
- WebSocket 연결 성공 시점에서 제거하여 TTL 회수 대상에서 제외
- 이 Map에 존재하는 상태는 "자원은 점유되었지만 WebSocket 연결은 확인되지 않은 상태"를 의미함

### 2. 스케줄러 기반 자원 회수 로직

```java
@Scheduled(fixedRate = 30000)
public void clearExpiredPermits() {
    long now = System.currentTimeMillis();
    for (var entry : createdAtMap.entrySet()) {
        if (now - entry.getValue() > TTL_LIMIT_MS) {
            semaphoreRegistry.release(entry.getKey());
            createdAtMap.remove(entry.getKey());
        }
    }
}
```

- 2분 기준 TTL (향후 정책 객체로 외부화 예정)
- WebSocket 연결이 성립되지 않은 방 번호만 남아 있음
- 스케줄러는 세마포어 내부 구조를 알 필요 없이 외부 타임맵만 순회함 → DIP 만족

### 3. 연결 성공 시 자원 확정 및 TTL 제거

```java
@Override
public void afterConnectionEstablished(WebSocketSession session) {
    Integer roomId = (Integer) session.getAttributes().get("roomId");
    if (roomId != null) {
        createdAtMap.remove(roomId);
    }
}
```

이 호출이 성공하면 자원 점유는 확정 상태로 전이되며, 더 이상 TTL 회수 대상이 아님을 의미한다.

---

## ✅ userMap(userId → timestamp)와 세마포어 간 동기화 여부

### 🎯 질문:
세마포어에서 `tryAcquire()` 성공 이후, userId를 별도 추적 맵에 넣는 건 동기화가 필요할까?

### ✅ 결론: **필요하지 않다**

| 이유 | 설명 |
|------|------|
| `tryAcquire()`는 CAS로 보호됨 | 자원 상태는 이미 안전하게 점유됨 |
| userMap은 자원 상태에 영향 없음 | 단순 메타데이터 추적 (유저 연결 실패 분석 등) |
| 동기화는 TTL 회수 시점에서만 주의 | `ConcurrentHashMap`으로 충돌 최소화 |

즉, 자원 상태 변경과 추적 정보 기록은 논리적으로 분리된 concern이며, 
두 연산이 동기화될 필요는 없다. 이 판단 기준은 실제 동시성 설계에서
불필요한 락 범위를 줄이는 핵심 기준이 된다.

이 설계는 단순 동기화 해제가 아니라, **동기화 경계를 명확히 선언하는 구조화된 설계 판단**으로, 고성능 처리를 지향하는 시스템에서 매우 중요하다.

---

## 📌 결론

- 자원 점유는 `joinService`에서 `tryAcquire()`로 선점하고, 이후 WebSocket 성공 시 확정됨
- 실패 시점은 서버에서 감지 가능 (`TransportError`, `ConnectionClosed`)
- JS 수신 실패 등 감지 불가능한 상태는 TTL 기반 회수 로직으로 보완됨
- 유저 ID 추적 로직은 자원 제어와 분리되므로, 구조적 동기화는 불필요

📌 이 구조는 동시성 충돌을 원천적으로 방지하고, 상태 정합성을 유지하면서도
불필요한 락을 최소화한 구조이며, 추후 메시지 큐 기반 확장에도 그대로 연동 가능하다.

또한 이 설계는 단순한 예외 처리가 아니라, 자원 상태 전이, 실패 감지, 관찰자 추적이라는 3계층의 상태 흐름을 의식적으로 구분하여 시스템 전체의 구조적 일관성과 확장성을 확보한다.