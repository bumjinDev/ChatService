[설계 구조 통제의 필수 인식 항목 – 3번 항목 보조 문서]

이 문서는 실시간 입장 통제 구조를 구현하기에 앞서, 설계자가 반드시 논리적으로 분해하고 구조적으로 정립해야 하는 핵심 판단 기준들을 정리한 것이다. 이는 단순히 “코드로 구현 가능한가”가 아니라, “이 구조가 어떤 기준으로 분기되고, 어떤 책임 단위로 나뉘어야 하는가”를 먼저 이해해야 전체 시스템이 비결정성 없이 동작하게 되는 설계 원칙에 해당한다.

1. 책임 분리 (Separation of Concerns)
- 이유: 큐는 요청 순서를 관리하고, 세마포어는 입장 허가 여부를 판단한다. 이 두 책임이 결합될 경우, 내부 상태 변경과 외부 허가 제어가 엉키며 구조적 오류가 발생한다.
- 통제 기준: “순서”는 큐가 가진 책임이며, “허가”는 세마포어가 통제한다. 이 둘은 반드시 분리되어야 한다.
- 설계 영향: JoinRequestQueueManager와 RoomSemaphoreManager는 절대로 통합되지 않는다.

2. 비동기 도달 분리 구조의 필요성 [해당 항목 설계에서 제거 - 혹시 모를 정합성 위해서 항목은 유지]
- 이유: REST API로 요청이 먼저 들어오고, WebSocket 연결은 나중에 발생하며, 두 요청은 실제로 다른 스레드에서 처리되므로 도달 순서가 역전될 수 있다.
- 통제 기준: 도달 순서는 통제할 수 없으며, 시스템은 “올바른 요청자가 올바른 타이밍에 도달했는가”를 감지하고 차단할 수 있어야 한다.
- 설계 영향: queue.peek()와 실제 WebSocket 사용자 ID의 비교 로직이 반드시 존재해야 하며, 이것이 없으면 구조가 파괴된다.

3. 상태 선점과 복원 구조의 필수성
- 이유: tryAcquire()는 자원을 소모하며, 입장이 실패하거나 중간에 예외가 발생할 경우 release()가 호출되지 않으면 자원이 누락된다.
- 통제 기준: 입장 흐름 내 어느 지점에서든 실패가 발생하면 release()로 반드시 선점 자원을 복원해야 한다.
- 설계 영향: afterConnectionClosed() 또는 예외 분기 내 release() 호출은 선택이 아니라 구조적 필수다.

4. 병렬 조건 분기의 명시적 선언
- 이유: “자원이 남아 있다”는 조건과 “요청 순서가 올바르다”는 조건은 서로 다른 기준이며, 둘 중 하나만 만족해도 입장을 허용하면 논리 파괴가 발생한다.
- 통제 기준: if (tryAcquire() && queue.peek().userId == currentUserId)처럼 두 조건을 병렬로 평가해야 한다.
- 설계 영향: 단일 조건 기반 분기(if (limit > curr))는 폐기되어야 하며, 복수 조건의 명시적 병렬 검증이 기본이 된다.

이 문서는 3번 기술 선택 및 구조적 근거 항목의 보조 자료로 사용되며, 실제 시스템 설계자가 "어디까지를 통제하고, 무엇을 외부 조건으로 받아들여야 하는지"를 명확하게 구분할 수 있도록 설계 기준을 구조적으로 정리한 것이다.