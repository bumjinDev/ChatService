
[최종 테스트 시나리오 정리]

■ 목표: 실시간 WebSocket 기반 채팅 시스템에서 발생 가능한 입장 충돌 및 상태 정합성 오류를 방지하는 구조 설계 및 검증

──────────────────────────────────────────────

1. 테스트 시나리오 명: 순서 불일치 재현 실험

- 기술적 배경:
  REST 입장 요청을 먼저 보낸 사용자와 WebSocket 세션이 먼저 형성된 사용자가 일치하지 않음. 이는 클라이언트의 네트워크 환경, 서버 스레드 풀 순서, WAS 내부 요청 큐 순서에 따라 비결정적으로 발생.

- 테스트 절차:
  1) 사용자 A, B가 동일한 방에 REST 요청 순서 A→B로 입장 시도
  2) WebSocket 연결은 B→A 순으로 지연 조작하여 역전 발생 유도
  3) afterConnectionEstablished() 시점의 사용자 ID 및 큐 선두 정보 로그 추적

- 검증 지표:
  - JoinRequestQueueManager.getValidRequestUserIds() 반환 결과와 실제 WebSocket 세션 유저 ID 일치 여부
  - 큐 선두(queue.peek())와 WebSocketSession.userId 일치 여부

- 포트폴리오 삽입 가능 포인트:
  - 비결정성 기반 race condition 재현 로그
  - 요청 순서와 실제 입장 순서의 구조적 불일치 증명

──────────────────────────────────────────────

2. 테스트 시나리오 명: 정원 초과 조건문 기반 입장 실패 검증

- 기술적 배경:
  if (currentPeople < limit) 형태의 조건문은 단일 스레드 기준에선 유효하지만, 동시성 환경에서 동일 인원 수를 여러 스레드가 참조하여 모두 입장 허용하는 race condition 유발

- 테스트 절차:
  1) 10명 정원이 설정된 방에 10개 이상의 스레드로 confirmJoinRoom() 동시에 호출
  2) @Transactional, synchronized 미사용 조건 하에서 테스트
  3) 입장 후 실제 DB 인원 수, 큐 길이 확인

- 검증 지표:
  - 큐 길이 > 정원 수 확인
  - WebSocket 세션 수 추적
  - 모두 success 응답인 경우 구조 결함 증명

- 포트폴리오 삽입 가능 포인트:
  - race condition 실증 로그
  - 동시 요청 환경에서 조건문 기반 처리의 한계 명시

──────────────────────────────────────────────

3. 테스트 시나리오 명: 세마포어 기반 구조 정합성 검증

- 기술적 배경:
  Semaphore.tryAcquire()는 원자적으로 permit을 점유하며, 실패 시 즉시 반환. 이는 CAS 기반으로 경쟁 조건을 회피할 수 있는 설계.

- 테스트 절차:
  1) permit 10개 설정 후 15개 요청 스레드 생성
  2) 성공/실패 분기에서 queue.add() 여부를 분기
  3) release() 호출 여부도 검증 (afterConnectionClosed 등)

- 검증 지표:
  - 성공 시 permit → 큐 추가 → 입장
  - 실패 시 permit 획득 실패 로그
  - queue.peek() → userId 비교

- 포트폴리오 삽입 가능 포인트:
  - 세마포어 획득-반납 전체 흐름 로그
  - 실패 시 거절 응답의 선명성
  - 구조적 이점 요약

──────────────────────────────────────────────

4. 테스트 시나리오 명: TTL 기반 큐 무효화 구조 검증

- 기술적 배경:
  JoinRequestQueueManager는 TTL 분기 로직을 통해 오래된 큐 요소를 제거함

- 테스트 절차:
  1) TTL을 5초로 설정
  2) REST 요청 후 6초 이상 지연된 WebSocket 연결 시도
  3) hasValidRequest(userId) 결과 false 여부 확인

- 검증 지표:
  - TTL 초과 요청 제거 여부
  - WebSocket 연결 시 큐 무효 상태 로그 및 차단 응답

- 포트폴리오 삽입 가능 포인트:
  - TTL 기반 큐 정화 결과 시각화
  - 유효 요청 판별 실패 시 입장 차단 구조 설명

──────────────────────────────────────────────

5. 테스트 시나리오 명: queue.peek() ≠ userId 차단 구조

- 기술적 배경:
  permit을 획득한 사용자와 queue.peek()의 userId가 다를 경우, 선입 선출 위배로 간주하여 차단

- 테스트 절차:
  1) A, B 사용자 순서로 큐 삽입
  2) B가 먼저 WebSocket 연결 → queue.peek()은 A
  3) 차단 및 release() 수행 여부 확인

- 검증 지표:
  - userId ≠ queue.peek() 시 disconnect
  - release() 호출 여부 로그

- 포트폴리오 삽입 가능 포인트:
  - 큐 선두 일치 검사 구조
  - 선입 선출 보장 로직의 실제 구현 증명

──────────────────────────────────────────────

■ 포트폴리오 문서화 항목 정리

- 구조별 흐름도: 요청 → 선점 → 유효성 검증 → 입장 처리
- 실험 구조 요약표: 구조별 실패 유형, 정합성, 처리 성능 비교
- 성능 비교 로그: tryAcquire, lock, 조건문 비교
- 비정합 로그 스냅샷: 순서 왜곡, TTL 만료, 정원 초과 실험 로그
- 이론적 정당화: Semaphore, CAS, ConcurrentQueue 활용 이유
