[최초 문제 인식 – 사용자 동시 입장 요청 시 발생하는 구조적 충돌]
실시간 채팅 시스템은 WebSocket 기반의 비동기 연결 구조를 전제로 작동하며, 클라이언트 측에서는 HTTP 기반의 REST 요청과 이후 WebSocket 전환을 통해 실제 입장 처리를 완결한다. 이 과정에서 동일한 방에 다수의 사용자가 동시에 입장 요청을 보낼 경우, 서버 측에서는 요청 도착 순서나 TCP 커넥션 순서, 혹은 Tomcat의 worker thread scheduling 순서 등에 따라 처리가 비결정적으로 이루어지며, 이는 설계자가 명시적으로 제어하거나 보장할 수 없는 영역이다. 이와 같은 조건에서 발생하는 근본적인 구조 충돌은 다음 두 가지로 명확히 관측되었다.

첫째는 입장 순서의 불일치 현상이다. REST API를 통해 입장 요청을 먼저 보낸 사용자와, 실제 WebSocket 세션이 먼저 연결되어 afterConnectionEstablished() 혹은 관련 핸들러에 먼저 도달한 사용자가 일치하지 않는 구조적 오차가 발생한다. 이는 네트워크 지연, 커널 큐 처리 순서, WAS 스레드 풀 할당 시점 등 다양한 외부 조건에 의해 발생하며, 사용자의 요청 처리 순서와 실제 입장 처리 순서 간의 불일치를 초래한다. 따라서 단순히 "요청을 보낸 사용자"를 기준으로 입장 순서를 정하는 것이 불가능해진다.

둘째는 입장 인원 초과 허용 문제이다. 특정 방에 최대 입장 가능 인원이 10명으로 설정되어 있다고 할 때, 다수의 사용자가 거의 동시에 WebSocket 연결을 시도하게 되면, 단일 시점에 여러 스레드가 현재 인원 수를 참조하여 입장 가능하다고 판단한 뒤 동시에 입장 처리를 강행할 수 있다. 이는 if (currentPeople < limit) 형태의 단순 조건문 기반 구조가 race condition을 감지하거나 회피하지 못한다는 점에서 근본적인 통제 실패를 의미하며, 실제 입장 인원이 설정보다 초과되는 비정합 상태로 귀결된다.

이 두 가지 문제는 공통적으로 “입장 요청의 시점”과 “입장 허용의 시점”이 논리적으로 일치하지 않으며, 그 사이에 시스템이 외부적 요소에 의해 입장 흐름을 통제 불가능하게 만드는 구조적 간극이 존재함을 나타낸다. 단순히 요청을 먼저 보냈다는 이유만으로 입장을 허용할 수 없고, 동시에 입장 가능 인원을 변수나 DB 필드로 동기화 없이 비교하는 방식은 통제 불가능한 동시성 오류를 유발하게 된다.

따라서 이 시점에서 문제는 단순한 구현상의 실수가 아니라, 구조적으로 서로 다른 세 가지 기준(요청 순서, 입장 시점, 현재 인원 수)이 설계자의 통제 밖에서 서로 충돌하고 있음에도 불구하고 이를 설계자가 하나의 블록이나 조건문으로 판단하고 처리하려 한 설계의 오류로 정의되었다. 이 구조적 충돌은 이후 모든 설계의 전제가 되었으며, 순서를 보존하는 구조와 자원을 선점하는 구조는 반드시 서로 다른 책임 단위로 분리되어야 한다는 인식으로 이어졌다.