
✅ Java `Semaphore`: 구조 통제형 동시성 제어자의 정의와 위상

Java의 `Semaphore`는 단순한 락 구현체가 아닌, 시스템 내 자원 동시 접근 제한을 구조적으로 통제하기 위한 카운팅 기반 동기화 제어 구조로, 하나의 자원에 다중 스레드가 동시에 접근하는 것을 허용하되 그 접근 가능 수량을 permit이라는 정수값으로 명시적으로 선언하며, 이 값을 통해 구조적으로 시스템 자원 상태를 통제한다. 이는 내부적으로는 `AbstractQueuedSynchronizer`(AQS)를 기반으로 하며, `state`라는 단일 필드를 통해 permit 개수를 추적하고, `tryAcquire`와 `release`를 통해 하드웨어 원자 연산인 CAS로 이 상태값을 통제하며, 필요 시 스레드 큐(CLHQ: CLH Queue)에 삽입하여 순차적 해제를 가능하게 한다. 이로써 `Semaphore`는 단순 조건 분기 로직을 초월하여, 시스템 레벨에서의 자원 선점 여부를 결정하는 runtime 권한 판단기로 작동하며, 공정성(fairness) 여부에 따라 선점 기회의 분배 방식이 바뀌고, 이는 전체 스레드 큐 관리 방식에 직접적인 영향을 미친다.

✅ 내부 구조: AQS 기반 구현체와 통제 대상의 분리

Java의 `Semaphore`는 외형적으로는 단일 클래스처럼 보이지만, 내부적으로는 다음 세 구성요소에 의해 분리된 구조로 작동한다:

1. state (volatile int):
   - 현재 남은 permit 개수를 나타냄
   - AQS가 관리하며, 모든 자원 통제는 이 정수값의 증감으로 표현됨
   - 이 값의 변경은 반드시 compareAndSetState()로 CAS 연산을 통해 수행됨

2. Sync extends AbstractQueuedSynchronizer:
   - 세마포어의 핵심 로직을 구현하는 내부 클래스
   - tryAcquireShared(int)와 tryReleaseShared(int)를 오버라이드하여 공유 리소스 동기화를 구현

3. CLH 대기 큐:
   - CAS 실패 또는 자원 부족 시 스레드를 대기열에 삽입하여 순차적으로 unpark()로 깨움
   - 단, 이는 acquire() 호출 시에만 작동하며, tryAcquire()는 절대 대기열에 진입하지 않음

✅ 메서드별 실행 흐름

1. tryAcquire()
- getState()로 현재 permit 수 확인  
- permit이 충분하면 compareAndSetState(old, old - acquireCount) 수행  
- 성공 시 true 반환 (permit 선점 완료), 실패 시 false 즉시 반환  
- ❌ CLH 대기 없음 → 즉시 시도-실패-종료 구조

2. acquire()
- 내부적으로 tryAcquire() 호출  
- 실패 시 doAcquireShared() 진입 → CLH 대기 큐에 스레드 삽입  
- LockSupport.park()로 해당 스레드를 중단 → 자원 복원 시 unpark()로 깨어남  
- 공정성(fair=true)일 경우, hasQueuedPredecessors() 검사를 통해 대기 선입자 존재 시 시도 자체를 제한

3. release()
- compareAndSetState(old, old + 1)로 permit 복원  
- 대기 큐에 스레드가 존재할 경우 → 하나 이상을 unpark() 호출하여 깨움

✅ 공정성 모드의 구조적 차이

- fair = false:  
  - tryAcquire() 시 선입 대기자 무시, state만 보고 CAS 수행  
  - CPU를 먼저 점유한 스레드가 선점 → 빠르지만 starvation 발생 가능  

- fair = true:  
  - hasQueuedPredecessors() 검사 후, 대기 선입자가 있으면 tryAcquire() 시도 금지  
  - 시도 자체가 제한되므로 진입 순서가 철저히 보장됨 → FIFO 기반 선점 흐름

✅ 시스템 설계에서의 구조적 위상

Java `Semaphore`는 다음과 같은 목적과 설계 원리를 갖는다:

- 자원 제어 책임을 독립 구조로 분리함으로써, 애플리케이션 로직과 자원 통제를 구조적으로 분리
- race condition을 회피하면서도 spin 없이 비차단적으로 자원을 통제 가능
- tryAcquire() 방식은 대기 큐를 생성하지 않기 때문에, 입장 실패 시 즉시 반환 및 메시지 처리 구조에 적합
- release()는 자원 복원 책임이 있으므로, 실패 분기 혹은 WebSocket 종료 시점에 반드시 호출되어야 시스템 상태 일관성이 유지됨

✅ 실시간 시스템에 적용할 때의 실무 판단 기준

| 조건                                    | 적용 방식                                            | 내부 동작                                   |
|------------------------------------|------------------------------------------------|-----------------------------------------|
| 동시성 자원 선점만 필요         | tryAcquire()                                         | CAS만 수행, 실패 시 false              |
| 자원 부족 시 스레드 대기 허용 | acquire()                                             | 실패 시 CLH 큐 진입, park/unpark  |
| 입장 실패 즉시 메시지 반환     | tryAcquire() + 실패 후 응답                    | CLH 미개입, 응답 로직 필요           |
| 구조적 공정성 요구 (선착순)    | fair = true + hasQueuedPredecessors()    | 대기 큐 선입자 검사                     |
| 성능 우선, 순서 무시              | fair = false                                           | 선점 경쟁 가능성 증가                  |

✅ 결론

Java `Semaphore`는 단순한 숫자 기반 카운터가 아닌, AbstractQueuedSynchronizer 기반의 CAS 원자 연산 + 선택적 CLH 큐 통제 메커니즘으로 동작하는 시스템 자원 제어 프레임워크이다. tryAcquire()는 non-blocking 흐름을 완벽히 제공하므로, 입장 실패 시 대기 없이 반환하는 구조에 정확히 적합하며, 설계자는 반드시 release() 시점과 예외 분기에서 자원 복원을 구조적으로 명시해야 시스템의 자원 누락이 발생하지 않는다. 이 구조는 락 프리 설계가 요구되는 고성능 실시간 시스템에서 동시성 오류를 제거하고 구조적 정합성을 보장하는 핵심 기초 단위로 작동하며, permit 수, 순서 조건, 공정성 옵션에 따라 다양한 시스템 흐름을 구현 가능하게 한다.
