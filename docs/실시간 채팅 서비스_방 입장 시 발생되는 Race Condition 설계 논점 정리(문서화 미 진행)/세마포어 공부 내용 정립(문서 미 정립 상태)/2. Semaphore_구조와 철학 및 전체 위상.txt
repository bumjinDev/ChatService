
===============================================
📘 [A] 구조 철학 및 전체 위상 – Java Semaphore
===============================================

이 항목은 Java의 Semaphore라는 기술 개념이 왜 존재하는가,
그리고 그것이 동시성 제어 체계 내에서 어떤 위상을 가지며,
다른 제어 도구들과 어떤 본질적 차이를 가지는가를 전제로
전체 구조의 목적과 존재 이유를 정리한다.

Semaphore는 단순한 API 사용법으로 접근할 수 있는 개념이 아니다.
이 구조는 시스템 설계 내에서 **"자원 통제 계층의 구성 요소"**로 위치하며,
설계자의 관점에서 자원 선점, 허가, 회복의 모든 흐름을 구조적으로 책임지는 메커니즘이다.

============================================================================

1. 🔍 세마포어의 존재 목적은 “구조적 자원 제어”다

Java의 `Semaphore`는 `tryAcquire()` / `release()`라는 API로 동작하지만, 그 철학적 배경은 단순한 **락 대체**가 아니다. `Semaphore`는 시스템 내에서 다음 두 가지 조건을 동시에 보장하기 위한 것이다:

동시에 접근 가능한 자원의 수를 제한하되 그 제한을 외부에서 명령어로 통제할 수 있는 구조적 진입 지점이어야 한다

이게 의미하는 건, 단순히 `동시성 제어 = synchronized`처럼 묶는 것이 아니라, “**몇 개까지 접근할 수 있도록 허용할 것인가**”라는 **자원 접근의 양적 기준을 구조 수준에서 선언하고 통제하는 것”**이다. 즉, `Semaphore`는 단순 실행 흐름을 멈추거나 허용하는 것이 아니라, **시스템 전체 자원의 진입 허용을 통제하는 권한자**로 설계된 것이다.

---

2. 🧱 시스템 설계 위상에서의 위치는 “자원 전단 통제자”

실시간 채팅 시스템, API 요청 제한기, DB 커넥션 풀, 트랜잭션 처리 등에서 `Semaphore`는 어디에 존재하는가?

- 비즈니스 로직 이후가 아니라, 비즈니스 로직 이전에 존재한다.
- 어떤 요청이 들어왔을 때, 그 요청이 자원 사용 자격이 있는지 없는지를 판단하는 가장 바깥쪽 경계에 위치한다.
- `tryAcquire()`는 “이 요청이 진입 가능한가?”를 판단하고,
- `release()`는 “이 요청이 자원을 반납했는가?”를 구조적으로 처리한다.

이건 단순히 if문 조건 체크가 아니라, **시스템 자원의 상태(state)를 통제하는 명령어**가 된다는 의미다.

---

3. Mutex나 Lock과의 본질적 차이는 “동시 허용성과 카운팅 추상화”

많은 개발자는 `Semaphore`를 락 계열로 오해하지만, 다음 차이가 있다:

| 구조                                       | 역할                                | 특징                          |
|--------------------------------------|---------------------------------|---------------------------|
| `ReentrantLock`, `synchronized`   | 단일 스레드만 진입 가능     | 진입 시 전면 차단        |
| `Semaphore(n)`                        | 최대 n개 스레드 진입 가능   | 자원 수량 기반 허용    |

즉 `Semaphore`는 스레드의 진입 자체를 제어하는 것이 아니라, "몇 개까지 들어와도 되는가"라는 자원의 양적 정의**를 먼저 두고, 그 정의에 따라 진입이 허용되는 구조 설계이다.

---

4. state 기반 통제 : 추상화 수준이 다르다

이제 중요한 기술적 본질: Java의 `Semaphore`는 `AbstractQueuedSynchronizer`의 `state` 값을 기반으로 자원 수량을 추적하며, `tryAcquire()`나 `release()`는 이 state 값을 `CAS` 연산으로 직접 증감한다.

이건 단순히 flag를 on/off 하는 게 아니라, 자원의 상태를 정수값으로 모델링하고, 이 값을 원자적으로 조작하여 시스템을 통제하는 구조적 방법이다.

- 예: `state = 2`이면, 두 개의 permit이 존재하고 두 개의 요청이 동시에 진입 가능
- 이 state는 `compareAndSetState()`를 통해 race condition 없이 원자적으로 제어됨
- 즉, 시스템의 접근 가능성 자체가 이 state라는 수치로 추상화된 것이다

---

5. 결론: Semaphore는 조건 분기의 수단이 아니라 “통제 구조의 설계자”다

`Semaphore`는 단순한 Boolean 조건 분기나 임계 구역 진입 여부를 판단하는 도구가 아니다.  
그것은 시스템 전체에서 자원이라는 개념을 수치화하고, 그 수치를 기반으로 사용자 진입을 허용/차단하며, 사용 후 반드시 반환시키는 책임을 구조적으로 강제한다.

비즈니스 로직은 자원을 “사용”하지만, 세마포어는 자원을 “허가/회수”한다.  
둘은 역할이 다르며, 세마포어는 실행 흐름이 아닌 **자원 흐름의 통제자**로 설계된 것이다.
