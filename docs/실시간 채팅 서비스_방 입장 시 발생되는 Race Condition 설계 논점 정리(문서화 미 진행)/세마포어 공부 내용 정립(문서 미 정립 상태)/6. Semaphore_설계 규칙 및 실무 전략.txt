
📘 [F] 설계 규칙 및 실무 적용 전략 – `Semaphore`의 전략적 통제 흐름 설계 조건
===============================================================================

1. 자원 진입 흐름을 통제하는 유일한 구조로 고정해야 한다
----------------------------------------------------------------
`Semaphore`를 시스템에 도입하는 순간, 해당 자원의 진입 조건은 반드시 `tryAcquire()` 혹은 `acquire()`를 통해서만 결정되어야 한다. 즉, 자원이 존재하는 영역에 조건 분기, if문, 사용자 정의 카운터, 논리 비교 등 다른 방법으로 진입 제어를 병행하면 허가되지 않은 상태로 자원이 선점되거나 누수되는 구조적 위반이 발생한다.
설계자는 반드시 “해당 자원은 `Semaphore`가 단독으로 통제한다”는 구조적 전제를 시스템 상단에서 선언하고, 해당 자원의 접근 지점에는 `tryAcquire()` 외의 판단 로직을 절대 배치하지 않아야 한다.

2. `release()`는 선택이 아닌 시스템 생존 조건이다
--------------------------------------------------------
permit을 획득한 모든 흐름은 정상 종료, 예외 종료, 브라우저 탭 강제 종료, 서버 장애 등 어떤 경우든 반드시 `release()`를 호출해야 한다. 이 책임은 자원 회복이 누락되는 순간 시스템의 자원 가용성이 점진적으로 고갈되며, 결국 `tryAcquire()`는 모든 요청을 거절하는 구조적 정지 상태에 도달하게 된다. 특히 WebSocket 세션, API 요청 응답 흐름 등에서는 비정상 종료 시점에 자원 회복을 보장할 수 있는 `finally`, `disconnect`, `afterConnectionClosed` 등의 경로를 구조적으로 설계해야 한다.
`release()`가 누락된 구조는 “시간이 지날수록 오류 확률이 증가하는 붕괴형 구조”이며, 설계자는 이를 강제화하는 테스트 케이스와 로그 추적 조건을 포함해야 한다.

3. `tryAcquire()`는 단순 비차단 호출이 아니라 “정책적 분기자”다
-----------------------------------------------------------
많은 개발자가 `tryAcquire()`를 “되면 되고, 안되면 말자” 수준의 단순 로직으로 해석하지만, 설계자의 관점에서는 이 호출이 시스템 정책을 실행 가능한 코드로 전환하는 핵심 분기점이다.

`tryAcquire()`를 사용하는 모든 흐름은 반드시 다음 세 가지 조건이 명시되어야 한다:
- 성공 시: 자원 사용 진입
- 실패 시: 시스템이 사용자에게 어떤 응답을 반환할 것인가
- 실패 로그 기록 여부: 추후 디버깅 및 경계 조건 분석을 위해 실패 케이스는 반드시 명시적으로 로깅되어야 한다

이처럼 `tryAcquire()`는 단순히 boolean 값을 반환하는 메서드가 아니라, 시스템이 “지금 이 요청을 수용할 수 있는가”를 정책적으로 판단하고 그 결과를 응답 흐름으로 전환하는 권한자로 작동해야 한다.

4. 공정성 조건은 동작 방식이 아닌 설계 목표에 따라 설정되어야 한다
---------------------------------------------------------------------
`fair=true`를 사용할지, `false`를 사용할지는 현재 시스템의 기대 순서 흐름이 어떤가에 따라 결정되어야 한다.
공정성은 단순히 스레드 순서를 결정하는 게 아니라, 자원 선점 조건 자체를 제한하는 정책이며, 이를 잘못 사용하면 오히려 처리를 지연시키거나 starvation을 야기할 수 있다.

- 실시간성, 빠른 응답이 핵심 → `fair=false`
- 대기 순서를 사용자에게 노출하거나, 큐에 의미가 있는 경우 → `fair=true`

설계자는 이 조건을 단순 성능 옵션이 아닌 시스템 서비스 모델의 철학을 코드에 반영하는 방식으로 판단해야 한다.

5. 테스트 기반 설계 증명 전략이 선행되어야 한다
----------------------------------------------------------
`Semaphore` 기반 흐름은 반드시 다음 테스트 시나리오를 통해 설계 정합성을 검증해야 한다:

- 허용 인원 초과 시 `tryAcquire()`가 정확히 false 반환하는지
- permit 반환이 누락되었을 때 시스템이 점진적으로 접근을 차단하는지
- 여러 스레드가 동시에 `tryAcquire()`를 호출했을 때, 단 하나만 성공하고 나머지는 실패하는지 (CAS 경쟁 조건)
- `release()`가 호출될 때, 대기 큐가 존재하는 경우 정확히 하나의 스레드가 깨어나는지

이 시나리오들은 단순 기능 확인이 아니라, 시스템이 의도한 정책대로 자원을 통제하고 있는지 검증하는 구조적 테스트이며, 설계자는 이를 명확히 문서화하고 자동화 테스트에 포함시켜야 한다.

6. 자원 상태와 순서 상태는 반드시 분리 관리되어야 한다
----------------------------------------------------------
많은 구조에서 자원의 수량과 순서를 하나의 큐나 리스트로 관리하려고 시도하지만, 이는 설계 상 치명적 오류다. `Semaphore`는 자원 허용 여부만 판단하며, 입장 순서, 사용자 식별, 대기열 번호 등은 별도의 queue 구조(예: `ConcurrentLinkedQueue`)에서 관리되어야 한다.

이 분리를 하지 않으면 다음과 같은 문제가 발생한다:
- 특정 유저가 큐에는 등록되어 있지만 자원 허가는 실패하는 상태
- 또는, 자원은 허가되었으나 순서상 맞지 않아 입장을 막아야 하는 상황

설계자는 반드시 `tryAcquire()` 성공 이후에만 queue 상태를 검증해야 하며, queue와 `Semaphore`를 병렬적으로 해석하여 상태 일관성을 유지해야 한다.

7. 로그, 모니터링, 복원 구조는 기본 내장되어야 한다
-------------------------------------------------------
자원 허용, 실패, 반환 등 모든 상태 변화는 로그로 기록되어야 하며, 특히 permit이 회복되지 않거나 예상보다 빠르게 소모되는 경우를 대비한 모니터링 지표가 필요하다. 또한 시스템 재기동, 세션 만료, 연결 단절 등 비정상 상태에서도 `Semaphore`의 state가 동기화된 상태로 복원될 수 있도록 Redis, DB, In-Memory 캐시 등을 통한 상태 동기화 및 복원 로직이 필요하다.

설계자는 `Semaphore`가 아닌 시스템 전반의 상태 회복 전략 속에 `Semaphore`의 상태도 포함시켜야 하며, 이를 누락할 경우 장애 복구 이후에도 자원 할당이 되지 않는 구조적 정지 상태가 발생한다.

정리하자면, `Semaphore`는 단순한 동기화 도구가 아니라 시스템 자원 접근 흐름을 구조적으로 통제하는 정책 결정자이며, 이 구조를 도입하는 순간 설계자는 시도 조건, 실패 처리, 복원 시점, 테스트 기반 증명, 상태 분리 구조, 로깅 및 복구 조건까지 모두 포함하는 책임을 갖게 된다. 이 책임을 제대로 설정하지 않으면 `Semaphore`는 시스템을 보호하는 것이 아니라 시스템을 무력화시키는 병목점으로 전락할 수 있다.
