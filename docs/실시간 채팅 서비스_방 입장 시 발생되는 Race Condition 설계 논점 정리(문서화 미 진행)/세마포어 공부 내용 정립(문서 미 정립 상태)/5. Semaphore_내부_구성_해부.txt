📘 내부 구성 해부 – Java `Semaphore`의 내부 구조와 구현 책임
======================================================================

1. Semaphore의 구조적 책임 위임 – 직접 통제가 아닌 간접 위탁 모델
Java의 Semaphore는 내부적으로 직접 permit 수를 저장하거나 자원 상태를 추적하지 않는다. 그 대신 모든 동기화와 상태 통제는 내부 정적 클래스인 Sync를 통해 **AbstractQueuedSynchronizer(AQS)**에게 위임된다. 즉, Semaphore는 자원에 대한 상태 보존 및 선점 충돌 해소 책임을 자체적으로 수행하지 않고, AQS라는 전용 동기화 프레임워크에게 넘김으로써, 자신은 “정책 결정자”로서만 남는다. 이 위임 구조는 구조적으로 자원 통제의 책임과 실행을 분리하는 방식이며, Semaphore는 자원의 수를 선언하고 허가하는 정책 주체이고, 실제 CAS, 대기 큐 진입, 해제는 AQS가 담당한다.

2. AQS의 state: 자원 상태의 단일 수치 표현
AQS는 내부적으로 volatile int state 필드를 갖는다. 이 필드는 Semaphore의 입장에서 permit의 개수를 의미하며, 자원 사용 가능 수를 나타내는 단일 상태 수치이다. 이 값은 getState()와 compareAndSetState()라는 메서드를 통해 읽고 조작되며, 단순 정수값처럼 보이지만 실제로는 시스템 자원의 전체 사용 상태를 수치화한 핵심 통제 변수다. 특히 compareAndSetState()는 하드웨어 레벨의 CAS 연산을 기반으로 하므로, 멀티스레드 환경에서도 락 없이 원자적 자원 선점 제어가 가능하게 된다. 이 구조는 단일 정수로 자원 전체를 모델링하고, CAS로만 조작하도록 강제하여 race condition을 구조적으로 제거한다.

3. 자원 요청 흐름: tryAcquireShared() 내부 동작
permit을 획득하려는 요청이 들어오면, Semaphore는 내부적으로 Sync 클래스의 tryAcquireShared(int acquires) 메서드를 호출한다. 이 메서드는 다음과 같은 흐름을 따른다:
현재 state를 읽어 자원이 충분한지 확인한다.
available - acquires 계산 후, 음수이면 즉시 실패 반환.
양수이면 compareAndSetState()로 CAS 연산을 시도하여 state를 감소시킨다.
CAS 성공 시 성공 반환, 실패 시 루프를 반복하거나 상위 호출자가 분기 처리한다.

이 과정은 Semaphore 내부에서 자원이 선점 가능한지 여부를 판단하는 핵심 판단기이자 원자성 보장 경합 분기 지점이다. 단 하나의 스레드만 CAS에 성공할 수 있으므로, 동시 접근 시점에서 정확히 한 스레드만 자원 점유를 확정받는다.

4. 실패 시 대기 흐름: acquire()와 CLH 큐 진입
만약 tryAcquireShared()가 실패하고, 호출자가 acquire()처럼 blocking 메서드였다면, AQS는 내부적으로 doAcquireShared()를 호출한다. 이 메서드는 현재 스레드를 CLH 대기 큐에 노드로 삽입하고, LockSupport.park()를 통해 스레드를 정지시킨다. 이 CLH 큐는 FIFO 순서 기반이며, 삽입 순서를 기준으로 공정한 wake-up을 보장할 수 있다. 이때의 핵심은 Semaphore 자신은 큐에 어떤 스레드가 들어갔는지 전혀 알지 못하며, 큐 관리, 스레드 상태 전이, park/unpark 모두 AQS가 전담한다는 점이다. 이는 설계적으로 Semaphore가 자원 상태만 보고 허가를 내리며, 경합 해소는 모두 동기화 프레임워크에게 넘기는 방식임을 보여준다.

5. 자원 복원 흐름: release()와 wake-up 구조
permit을 반환할 때 호출되는 release()는 내부적으로 tryReleaseShared()를 호출한다. 이 메서드는 다음 흐름으로 동작한다:

현재 state를 읽어 permit 수에 반환 수량을 더한다.
compareAndSetState()로 CAS를 통해 state를 증가시킨다.
CAS 성공 후 AQS의 doReleaseShared()를 호출하여 대기 큐의 다음 노드를 깨운다.

이 구조에서 Semaphore는 permit 회복만 수행하고, 어떤 스레드를 깨울지, 공정성 조건을 판단할지는 AQS가 전적으로 결정한다. 다시 말해 Semaphore는 자원을 얼마나 회복했는지까지만 알고, 그 회복의 대상이 누구인지는 통제하지 않는다. 이로써 AQS와의 역할 분리가 명확하게 유지되며, Semaphore는 “자원 상태를 조작하는 컨트롤러”, AQS는 “스레드 큐를 제어하는 스케줄러”로 분업된다.

6. 비차단적 구조: tryAcquire()는 대기 없이 즉시 반환
Semaphore의 tryAcquire()는 tryAcquireShared()의 실행 결과에만 의존하며, 실패 시 doAcquireShared()로 진입하지 않고 즉시 false를 반환한다. 이 차이로 인해 tryAcquire()는 절대 CLH 큐에 스레드를 삽입하지 않으며, 대기 스레드도 발생시키지 않는다. 이는 Semaphore를 비차단적 흐름으로 사용할 수 있는 이유이며, WebSocket 접속, API 요청 허가 등 “실패 시 곧바로 거절해야 하는 실시간 흐름”에 이상적으로 적합하다. 내부적으로 큐가 작동하지 않는다는 점에서, tryAcquire()는 경량 흐름 분기 로직과 자원 제한 정책이 만나는 가장 이상적인 인터페이스가 된다.

7. 구조적 종합: 책임 위임 기반 고밀도 자원 제어 구조
전체적으로 Semaphore는 직접 상태를 추적하지 않으며, permit이라는 개념을 AQS의 state 필드에 위임하고, 자원 선점 판단도 AQS의 tryAcquireShared()에, 대기 큐와 스레드 관리도 CLH 기반의 AQS 내부 큐에 전담시키며, 자신은 오직 허가와 반환이라는 정책 판단자 역할만 수행한다. 이로써 Semaphore는 락을 사용하지 않고, CAS와 AQS를 기반으로 자원을 정밀하게 통제하는 고밀도 구조 통제자로 작동하게 되며, 내부 구성은 단순해 보이지만 실행 시점마다 책임과 조건이 명확히 분리된 설계 모델로 구축된다.

