📌 주제 01 – WebSocket 세션 구조와 중복 로그인 제어

■ 요약 정리
실시간 채팅 시스템의 WebSocket 구조는 브라우저 JS 컨텍스트 단위로 세션이 형성되며, 하나의 사용자 ID로 여러 브라우저 또는 탭에서 동일 채팅방에 중복 연결이 가능하다. 이는 단일 사용자에 의한 인원수 중복 점유와 사용자 수 오차, 퇴장 처리 누락 등을 야기한다. 이를 해결하기 위해 WebSocket 레벨에서 userId 단위로 세션을 추적하고 중복 세션 발생 시 기존 세션을 강제 종료하는 로직을 적용한다. 그러나 브라우저 단위 중복 로그인 제어를 위해서는 HTTP 세션 키(jsessionId) 또는 JWT 인증 토큰 기반의 중앙 제어가 필요하며, Redis 등을 활용한 세션 키 검증 및 무효화 처리와 WebSocket 핸들러 내 연계가 요구된다.

■ 상세 설계 정리

[탭 단위 이중 로그인 방지 구조 정리]

1. 문제 정의
- 동일 브라우저 내에서 여러 탭을 열고 채팅방에 접속할 경우, 동일한 사용자 ID가 동일한 roomNumber로 다중 WebSocket 세션을 유지함.
- 이는 사용자 수 집계 오류, 채팅 메시지 중복 수신, 퇴장 시 상태 동기화 누락 등의 문제를 유발함.

2. 설계 철학
- 하나의 브라우저 내에서 동일 userId가 동일 roomNumber로 두 개 이상의 WebSocket 연결을 시도할 경우, 이전 탭의 연결을 강제로 종료시킴.
- WebSocketHandler 단에서 roomNumber + userName 을 기준으로 메모리 기반 세션 레지스트리(ChatSessionRegistry)에 등록.
- 이미 동일한 userName으로 등록된 WebSocketSession이 존재할 경우, 이전 세션을 close() 호출로 강제 종료하고 새로운 세션으로 교체.

3. 작동 구조
- afterConnectionEstablished():
    - session.getAttributes().get("roomNumber")와 session.getAttributes().get("userName")을 기준으로 기존 세션 존재 여부 확인.
    - 기존 세션이 존재하며 isOpen() 상태이면, 이전 세션을 4000번 코드("중복 접속으로 기존 세션 종료")로 종료.
    - 이후 새로운 세션을 등록.
- onWebSocketClose():
    - 강제 종료 시 closeEvent.code 값을 클라이언트 JS에서 감지하여 "중복 로그인으로 인한 종료" 사유를 확인.
    - JS에서 해당 종료 사유를 사용자에게 알리고 자동으로 다른 페이지로 redirect 처리.

4. 클라이언트(JS) 처리
- WebSocket.onclose 이벤트에서 closeEvent.code === 4000 을 감지하면,
    - alert("다른 탭에서 동일 ID로 접속하여 연결이 종료되었습니다.");
    - window.location.href = "/ChatService/rooms";

5. 기술적 고려사항
- 세션 종료 메시지를 서버에서 broadcast 하기 전에, 메모리 레지스트리에서 완전 제거하는 순서를 보장해야 함.
- 사용자의 채팅 메시지를 보낼 때, session.isOpen() 여부를 반드시 확인 후 송신 처리.

6. 향후 확장
- 탭 간 로컬 스토리지나 BroadcastChannel API 등을 활용하여 보다 사용자 친화적인 실시간 통지 시스템으로 확장 가능.



[WebSocket 기반 실시간 채팅 시스템 설계 항목 - 브라우저 단위 이중 로그인 강제 차단]

1. 구조적 문제 정의:
- JWT 기반 인증은 Stateless 하므로, 서버 측에서 별도 로그아웃 처리 없이도 브라우저 탭, 브라우저 인스턴스 단위의 동시 로그인이 가능.
- 이로 인해 동일 userId 기반으로 다수 WebSocket 세션이 생성되며, 사용자 수 통계 오류, 중복 메시지 수신, 퇴장 미처리 등의 정합성 문제가 발생함.

2. Redis 기반 해결 전략:
- 기존 구조: Redis <토큰 값> → <서명 키>
- 개선 구조: Redis <userId> → [<토큰 값>, <랜덤 토큰 비밀번호>]

3. 동작 흐름:
[LoginFilter 클래스]
- 사용자가 로그인 요청 시, Redis에서 해당 userId 키 존재 여부 확인.
- 존재 시 Redis 내 저장된 토큰 값과 현재 로그인 요청 쿠키 내 토큰 값을 비교.
    - 동일: 기존 쿠키 유지하며 200 OK 응답만 반환 (중복 로그인 아님).
    - 상이: 이전 토큰 무효화 → Redis 내 userId 키 갱신 → 새로운 쿠키 반환 (브라우저 전환 간 중복 로그인 차단).

[JwtAuthProcessorFilter 클래스]
- 기존 방식 유지하되, Redis 구조만 <토큰 값> → <키>에서 <userId> 기반 토큰 구조로 변경하여 연동.
- 현재 브라우저 쿠키 내 토큰 값이 Redis 내 userId 키 값과 불일치 시 검증 실패.

4. WebSocket 진입 시 처리:
- HandshakeInterceptor 에서 HttpServletRequest 내 쿠키 확인 및 userId, 토큰 추출.
- Redis 내 userId → 토큰 값 조회하여 불일치 시 Handshake 자체 거부.

5. 효과:
- 로그인 시점에서 브라우저 단위 중복 로그인 즉시 감지 가능.
- 채팅 진입 전 사전 차단 가능 → 세션 낭비 방지.
- Redis TTL로 전역 만료 처리 가능하므로, 불필요한 복잡도 없음.

6. 한계:
- 이전 브라우저(예: 크롬)에서 채팅 탭 열어놓은 상태에서, 다른 브라우저(예: 엣지)에서 로그인하면 크롬 탭 연결은 유지됨.
    → 단, WebSocket 두 번째 연결 시 새로운 요청은 JWT 불일치로 거부되며, 기존 연결도 서버가 종료시킴.
- 즉, 채팅 탭 간 중복은 자동 차단되며, 브라우저 간은 로그인 시점에서 단절.

[면접 활용 포인트]
- Stateless JWT 인증 체계에서 Redis 기반 상태 관리를 통해 다중 접속 관리한 사례.
- Token 관리 단위와 Key-Value 재설계로 시스템 일관성 확보.
- 실시간 연결과 인증 체계 통합 고려 사례.


7. 요약 결론
- 사용자 단위의 WebSocket 세션 제어는 JS 단위 세션 분할 문제를 해결하나, 브라우저 수준 중복 로그인은 Redis 및 인증 토큰 기반 구조와의 연계로만 해결 가능.
- 전체 구조는 실시간성, 세션 정합성, 사용자 경험 일관성, 보안성 확보를 위한 필수 전제 조건이며, WebSocket 구조는 이 흐름 내에서 메시지 전달 계층으로써만 기능함.
- 최종 구조는 Spring Security의 필터 체인과 WebSocket 핸들러 간 인증 연계를 중심으로 하며, 인증 상태 무효화는 Redis를 통한 세션 키 확인으로 정합성 유지가 가능하다.