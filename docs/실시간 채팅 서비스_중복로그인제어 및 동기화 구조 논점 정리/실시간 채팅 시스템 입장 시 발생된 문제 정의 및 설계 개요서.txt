[문서 제목] 실시간 채팅 시스템 입장 제어 설계 개요서

────────────────────────────────────────────

1. 설계 철학 및 구조적 필요성

실시간 채팅 시스템에서의 입장 제어는 단순히 사용자의 연결 시도에 대해 허용 여부를 판단하는 문제가 아니라, 복수 사용자 요청이 거의 동시에 들어오는 상황에서 시스템이 자원 상태를 어떻게 통제하고, 실패 및 예외 상황에서 어떤 방식으로 상태를 정리하며, 분산 환경으로의 확장이 가능한지를 총괄하는 시스템 핵심 제어 축에 해당한다. 특히 WebSocket 기반 시스템은 연결 수립 이후 지속적 통신 채널을 유지한다는 특성상, 초기 입장 시점에서의 상태 오염은 이후 모든 메시징/세션 관리 계층에 중대한 파급을 일으킨다. 따라서 입장 제어는 다음의 세 가지 기술 전제를 모두 만족하는 구조로 설계되어야 한다:

- 실시간성 (즉시 응답과 빠른 실패 처리)
- 정합성 (중복 입장 방지 및 자원 상태 정확성 확보)
- 확장성 (다중 인스턴스 기반 운영에 대한 구조 확장 대응)

이에 따라, 본 설계는 REST ↔ WebSocket으로 구성된 이원적 입장 흐름의 논리적 연속성과, 상태 추적을 위한 추상화 계층을 내부적으로 어떻게 구성할 것인가를 중심으로 이루어진다.

────────────────────────────────────────────

2. 구조 단절 문제와 설계적 재정의

기존 구조는 다음과 같이 동작했다:

- 사용자 브라우저 → Spring Controller → 입장 가능 여부 판단 → JSP 반환
- JSP 내부 JavaScript → WebSocket 연결 → 실제 입장 처리

이 구조는 사용자 단에서는 자연스럽지만, 시스템 관점에서는 다음과 같은 구조적 단절 문제를 초래한다:

- 자원 점유와 상태 검증이 서로 다른 계층에서 발생함
- WebSocket 연결 실패 시 자원 복구 시점이 불분명함

이러한 문제는 단순 예외 상황에서 구조적 정합성 붕괴를 야기하며, 특히 최대 인원 제한과 같은 제약 조건이 있는 시스템에서는 race condition과 유령 세션/유령 방 발생의 원인이 된다.

────────────────────────────────────────────

3. 입장 흐름 재설계 방향

따라서 본 설계는 입장 흐름을 논리적으로 다음과 같이 재구성한다:

- 1단계: REST API 기반 사전 검증 + 자격 부여 + 대기열 등록
- 2단계: WebSocket 연결 요청 시 대기열 검증 후 실제 자원 점유 및 입장 처리

이 구조는 "예약 기반 자원 점유 흐름"으로 정의되며, 실시간성, 정합성, 확장성이라는 세 요건을 모두 충족하는 구조로 설계되었다. 여기서 중요한 것은 단순히 큐를 사용하는 것이 아니라, 상태를 표현하는 주체를 "입장 자격"으로 분리하고, 그 자격을 추상화된 자료구조(예: 큐, Redis, Lua script)로 관리함으로써, 연결 이전 시점의 자격과 연결 이후 시점의 입장 확정을 분리하는 것이다.

────────────────────────────────────────────

4. 구조 선택지와 적용 방식 요약

전체 입장 제어 구조는 다음의 세 가지 방식으로 분기 적용되며, 이는 테스트 환경과 실제 운영 환경에 따라 선택적으로 적용 가능하다:

- 조건 기반 상태 분기 모델: 현재 인원 수 + 큐 대기 수 < 최대 정원 여부만 판단하여 빠른 실패 및 즉시 큐 삽입 처리
- 세마포어 기반 추상화 모델: 자원 수량 자체를 추상화한 후 tryAcquire()를 통해 자격을 선점하고, 연결 실패 시 복구 로직을 별도로 구성
- Redis 기반 상태 제어 모델: 분산 환경에 대응 가능한 Redis의 INCR/DECR, Lua 기반 원자 연산을 통해 자격 부여, 검증, 만료를 통합적으로 수행

이 문서는 위 세 가지 방식의 전체 철학적 전제와, 해당 구조들이 왜 선택되고 어떻게 설계되었는지에 대한 상위 개요를 제공하며, 구체 구현 및 책임 분리 구조는 각각 별도 문서로 분리된다.
