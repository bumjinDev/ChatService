# 실시간 채팅 시스템의 입장 동시성 문제 및 구조적 해결 설계

## 1. 프로젝트 맥락 및 동시성 문제 정의: 채팅방 입장에서의 동시 접속 경쟁 현상

본 프로젝트는 다수의 사용자가 실시간으로 소통하는 채팅 서비스를 개발하는 것을 목표로 하며, 핵심 동시성 문제는 채팅방의 최대 인원 제한이 존재할 때 복수 사용자가 거의 동시에 특정 방에 입장 요청을 보낼 경우 설정된 인원수를 초과하여 입장이 이루어지는 레이스 컨디션(Race Condition)이 발생할 가능성이다.

예컨대, 9명이 있는 방에 두 명이 동시에 입장을 시도하면 양쪽 모두 조건 "9명 < 10명"을 통과하여 결과적으로 11명이 입장하게 되는 현상이 발생할 수 있다. 이 문제는 Check-Then-Act 패턴의 구조적 한계에서 비롯되며, 확인 시점과 조작 시점 사이의 상태 변경에 대응하지 못함에 기인한다. 문제의 기초 원리를 파악하기 위해 OpenCSF Synchronization Overview 등의 자료를 기반으로 임계 영역(Critical Section)과 동기화(Synchronization)의 필요성을 사전 학습하였다.

## 2. 기존 구조의 문제점: REST-WS 이원 구조로 인한 상태 불일치와 자원 누수

기존 실시간 채팅 시스템의 방 입장 흐름은 다음과 같이 이원화된 분산 처리 구조로 설계되어 있었다. 사용자가 채팅방에 입장하려 할 경우, 먼저 Spring MVC Controller를 통해 방 번호를 포함한 입장 요청을 전송하면, 해당 컨트롤러는 Service 계층을 호출하여 해당 방이 존재하는지, 정원이 초과되었는지를 판단한 후 방 페이지를 반환하고, 이후 페이지 내부의 JS 코드가 WebSocket 연결을 수행하는 방식이다. 이 구조는 직관적으로 단순해 보이나, 설계상 다음과 같은 치명적인 결함을 내포하고 있다.

Spring MVC 기반 구조에서 사용자는 먼저 RESTful 방식으로 입장 요청을 보내고, 이 요청은 서버 측 Controller와 Service 계층을 거쳐 DBMS에 사용자 요청에 대응하는 방이 존재하는지 확인하거나 필요 시 방을 생성하고, 입장 가능한 상태라면 View를 반환한다. 이때 DBMS 레벨에서 방 생성 및 인원수 초기화와 같은 작업은 이미 완료된 상태이다. 이후 클라이언트는 해당 View에서 WebSocket을 통해 채팅 서버와 연결을 시도하게 되는데, 이 과정이 네트워크 지연, 브라우저 종료, handshake 실패 등으로 인해 실제로 성립되지 않을 경우, 앞서 수행된 DB 작업과 사용자 실제 접속 상태 사이에 불일치가 발생하게 된다. 즉, DB 자원은 이미 점유되었지만 WebSocket 상에서는 접속이 이루어지지 않아 시스템 상태에 모순이 발생하며, 이는 자원 누수 및 유령 방 문제로 이어진다. 결과적으로, 사용자가 Spring Controller를 통해 입장 가능 판단을 받은 후 WebSocket 연결 과정에서 네트워크 지연, 클라이언트 종료, 브라우저 비정상 동작 등으로 연결이 실패할 경우, 입장 가능 판단만 이루어진 채 자원 점유는 이루어지지 않은 비일관 상태가 발생하게 된다.

Spring MVC Controller와 WebSocket 핸들러는 서로 별개의 네트워크 계층에 속해 있으며, 기본적으로는 명시적인 상태 공유 수단이 존재하지 않는다. 따라서 Controller에서 판단된 입장 가능 여부나 사용자 인증 결과는 WebSocket 핸들러에서 별도로 확인할 수 없으며, 상태 공유를 위해서는 명시적으로 공유 가능한 상태 객체를 웹소켓 핸들러와 서비스 계층 양측에 걸쳐 참조 가능하도록 구조화해야 한다. 본 프로젝트에서는 이를 위해 WebSocket 핸들러와 RoomJoinService 양측 모두에 SemaphoreRegistry를 의존 주입하여, 입장 허용 여부 판단과 입장 확정 단계 모두에서 동일한 상태 객체를 활용한다. 이러한 구조적 연계는 단순 인증 검증이 아니라, 상태 소유권을 통합 관리하는 설계를 하였다.

Spring Controller 계층은 @ExceptionHandler 또는 @ControllerAdvice를 통해 적절한 HTML 또는 View 기반 응답을 제공할 수 있지만, WebSocket은 기본적으로 상태 코드(예: 4001, 4003 등)와 함께 연결 종료(CloseStatus)만 가능하므로 정제된 피드백 전달 구조가 없다. 결과적으로, 사용자가 어떤 이유로 입장에 실패했는지 알 수 없으며, 입장 실패의 원인을 알 수 없는 블랙박스 구조가 된다.

사용자의 입장 요청이 실제 입장까지 이어지지 않으면, 입장 요청은 DBMS에서 방을 생성하거나 인원수를 증가시키는 방식으로 우선 반영되지만, 이후 WebSocket 세션이 정상적으로 성립되지 않을 경우 해당 자원은 실제 사용자 연결 없이 DB에만 잔류하게 되어, 시스템 입장에서는 리소스가 낭비되거나 상태 불일치가 발생하는 문제가 생긴다. 이는 세마포어 유무와 무관하게, REST 요청에 따른 상태 선반영과 WebSocket 연결 실패 사이의 시간 차에서 비롯된 구조적 문제이다. 다만, 세마포어가 존재하는 구조에서는 입장 허가 자체를 제어할 수 있기 때문에, DB 반영 이전에 사전 차단이 가능해지는 여지가 존재하며, 결과적으로 상태 고착의 빈도나 범위를 일부 제한할 수 있다. 특히, 방을 새로 생성해야 하는 경우에는 방 메타정보 테이블이 먼저 생성되고 사용자가 연결되지 않음으로써 실제로는 사용되지 않는 유령 방이 DB에 남아 있는 상태가 된다. 이를 정리하기 위해 스케줄러가 존재하더라도, 본질적으로 상태 전이 흐름이 분리되어 있다면 복구는 항상 사후적이며 불완전하다.

## 3. 구조 개선 방향: 컨트롤러-핸들러 간 상태 연계 기반의 2단계 입장 구조

위와 같은 근본적인 문제를 제거하기 위해, 본 설계는 방 입장 과정을 두 단계로 분리하되, 흐름상 단절이 없는 논리적 연속선 내에서 재구성하는 것을 목표로 한다. 즉, 1단계(Spring Controller)는 입장 검증 및 예약(신규 방 생성 대기열 등록)을 수행하고, 2단계(WebSocket)는 예약 확인 후 최종 자원 점유 및 입장을 수행하는 구조로 개선된다.

이를 통해 다음과 같은 정합성과 실무적 이점을 확보한다:
- 입장 가능 여부 판단과 자원 점유 확정은 서로 비동기적인 단계에서 수행되지만, 두 단계 모두 동일한 사용자와 roomId에 대해 공유되는 상태 객체(SemaphoreRegistry, InMemoryRoomQueueTracker)를 기반으로 처리되므로, 전체 입장 흐름은 논리적으로 일관된 통제 구조를 유지한다
- 예외 발생 시점이 1차 Controller 계층으로 집중되어 @ExceptionHandler 기반의 정제된 피드백 가능
- WebSocket 단에서는 오직 예약된 사용자만 입장을 승인함으로써 보안성과 방어적 로직 강화

## 4. 내부 구현 구조: 서비스 책임 분리와 세마포어 기반 동시성 통제

현재 프로젝트의 실제 구현에서는 RoomJoinService가 입장 흐름을 다음 두 단계로 명확히 분리하여 처리한다:

- `confirmJoinRoom()` : 사용자가 방에 입장할 수 있는지 사전 검증을 수행한다. 먼저 요청된 roomId가 아직 DB에 존재하지 않는 신규 생성 대기 방인 경우, InMemoryRoomQueueTracker를 통해 방 생성 요청만 등록되며, 실제 DB 반영은 WebSocket 연결 시점에서 이루어진다. 반면 roomId가 DB에 존재하는 기존 방의 경우에는, 입장 조건 검증과 함께 SemaphoreRegistry를 통해 해당 방의 permit(세마포어)을 점유하여 동시 입장 제어를 수행한다. 이 메소드는 DB에는 어떠한 상태도 반영하지 않으며, 순수하게 입장 시도 자격을 판단하는 역할에 집중된다.

- `joinRoom()` : 이 메서드는 WebSocket 연결이 정상적으로 성립된 이후 호출되는 입장 확정 로직으로, 방이 DB에 존재하지 않으면 InMemoryRoomQueueTracker에 등록된 생성 요청을 조회해 실제 DB에 반영하며, 이후 입장 인원 수를 증가시킨다. permit은 이 시점까지 보존되어 있어야 하며, 이미 confirmJoinRoom()에서 확보된 상태가 전제이다.

### 예외 처리 및 상태 복구 책임 흐름

`joinRoom()` 실행 도중 DB 트랜잭션 내부에서 예외가 발생하거나, WebSocket 연결 도중 클라이언트 세션이 종료되는 등의 문제가 발생할 경우, 시스템은 두 계층에서 분리된 복구 루틴을 병행해야 한다. 첫째, 이미 확보된 permit은 반드시 afterConnectionClosed() 또는 handleTransportError()에서 명시적으로 release되어야 하며, 그렇지 않으면 해당 roomId에 대해 추가 입장이 차단되는 permit 누수 상태가 발생하게 된다. 둘째, InMemoryRoomQueueTracker에 등록된 방 생성 요청은 WebSocket 미연결 상태에서 TTL 기반으로 주기 스케줄러가 삭제를 수행하거나, joinRoom() 내부에서 조회 실패 시점에 즉시 삭제 또는 무효화 처리가 동반되어야 한다. 이 과정을 통해 유령 방 생성 요청 또는 잔존 메타데이터가 GC되지 않는 구조적 병목을 방지할 수 있다.

또한, afterConnectionClosed()는 의도적 종료뿐 아니라 비정상 종료(예: 네트워크 단절, 클라이언트 종료)까지 포함하여 작동해야 하며, 이 시점에서 ChatSessionRegistry의 세션 삭제와 permit 반환이 모두 일관되게 수행되어야 한다. 연결되지 않은 세션이 permit만 보유하고 있는 상황은 구조적으로 방치되어서는 안 되며, 이는 WebSocket 연결 실패 이후에도 리소스가 계속 잠식되는 상태이기 때문이다. 이런 상태 누락은 시스템 가용성을 장기적으로 침식시킬 수 있으며, 따라서 예외 복구는 단순 예외 핸들링이 아니라 시스템 자원 관리의 연속성 책임으로 간주되어야 한다.

요약하자면, 예외 처리 책임은 핸들러 내부 예외 콜백과 상태 캐시 스케줄러 양측에 걸쳐 분산되며, 그 협력에 의해 시스템 상태의 자동 복원 가능성이 확보된다. 이 구조는 단순한 try-catch 레벨의 예외 대응이 아니라, 시스템 정합성 보존을 위한 사후 정리 패턴(post-failure hygiene routine)으로 설계되어야 한다.

InMemoryRoomQueueTracker는 DB에 아직 생성되지 않은 채팅방의 생성 요청을 임시적으로 추적하는 구조로, 사용자가 REST 기반 Controller를 통해 신규 채팅방을 생성하고자 할 때 해당 요청을 등록해두고, 실제로는 WebSocket 연결이 성립된 이후에만 DB에 방 생성 작업을 수행하도록 유예하는 역할을 수행한다. 이 객체는 단순한 중복 요청 방지용 캐시가 아니라, 방 생성 요청을 즉시 DB에 반영하지 않고, 사용자의 실제 입장 확정 시점(WebSocket 연결 완료 시점)까지 지연시키는 비동기 전이 컨트롤러로 작동한다. 이 구조는 REST 요청에 따라 방을 즉시 생성할 경우, 클라이언트가 WebSocket 연결을 수행하지 않거나 중간에 네트워크 장애 또는 페이지 이탈이 발생할 경우, 입장되지 않은 방이 DB에 남게 되는 유령 방 문제가 발생하며, 이는 자원 낭비로 이어진다. 따라서 이 구조는 방 생성 요청의 사전 등록은 허용하되, 실제 반영은 입장 확정 시점에서만 수행하도록 시스템 상태 반영 타이밍을 지연시키는 전략이다. joinRoom() 메서드 내부에서는 해당 roomId가 DB에 존재하지 않을 경우, InMemoryRoomQueueTracker에서 사전 등록된 RoomQueueVO 객체를 조회하여 방 생성을 수행한다. 만약 이 메타정보가 존재하지 않거나, TTL이 초과된 상태로 제거되었다면, 방 생성 요청은 무효화되며 입장이 거부된다. 이는 방 생성 요청과 실질적 입장 의사 사이에 시간적 괴리가 발생하는 구조에서 정상적인 전이만을 통과시키고, 중도 이탈자나 비정상 요청을 배제하는 필터 구조로 설계된 것이다. 또한, 이 구조는 입장 대기열과 분리된 책임을 가지며, 단일 사용자 또는 단일 트랜잭션 단위의 방 생성 요청만을 수용한다. 동시 생성 요청에 대해서는 roomId를 키로 하는 ConcurrentHashMap 기반의 상태 추적 구조를 통해 선점된 요청만이 유효하게 작동하며, 이후 요청은 중복으로 간주되어 무시된다. 이는 방 생성 요청이 서로 경합하는 경우에도 오직 하나의 요청만이 시스템 상태를 반영하도록 보장하며, 비결정적 생성 문제를 구조적으로 회피한다. 요약하자면, InMemoryRoomQueueTracker는 단순한 캐시가 아니라, “Controller에서 발생한 방 생성 의사”와 “WebSocket에서 확정된 입장 동작” 사이의 정합성을 보장하는 비동기 전이 필터이며, 이를 통해 방 생성 로직을 사용자 실질 입장 시점으로 밀어냄으로써 시스템 자원의 정합성과 유효성을 보장하는 구조적 토대를 제공한다.

## 5. 입장 흐름 시나리오 및 동기화 전략 비교 설명

본 절은 본 설계의 실질적 흐름을 이해하기 위한 보조 해설로, 입장 과정의 시나리오 기반 설명과 동시에 과거 설계 대안으로 검토된 동기화 전략에 대한 비교 근거를 기록한다.

### 5.1 입장 흐름 요약 (2단계 분리 관점 재정리)

Spring MVC Controller에서 사용자 요청이 들어오면 `confirmJoinRoom()`에서 사전 자격을 검증한다. 이때 세마포어 구조(`SemaphoreRegistry`)를 사용하여 입장 자격을 판단하고, 성공 시 View 응답을 반환한다. 사용자는 View 내 JS 스크립트를 통해 WebSocket 연결을 시도하고, 이 시점에서 `afterConnectionEstablished()` 내에서 userId 및 roomId의 상태를 확인하고, 입장 자격이 확인된 경우 `joinRoom()`을 호출한다. 이후 세션 등록, permit 정리, broadcast 대상 세션 풀 등록 등이 진행된다.

### 5.2 동기화 전략 비교 정리 (조건 기반 분기 vs 세마포어)

- **세마포어 방식** : 자바의 `tryAcquire()`를 통해 사용자 단위로 자원 점유를 명시적으로 수행하며, 입장 충돌이 발생하지 않도록 한다. 구조적으로 단일 Thread만이 자원을 점유할 수 있도록 보장하며, 상태 경합이 발생해도 순서성이 보장된다.

- **조건 기반 상태 판별 방식** : 단순히 DB + 대기열 인원을 기준으로 최대 인원 조건을 평가한 뒤 입장 여부를 판단한다. 자원 점유를 수반하지 않으므로 race condition이 발생할 수 있으며, 비동기 구조에서는 예측 불가능한 상태 오류가 발생한다.

### 5.3 대기열 구조와 방 생성 구조의 역할 설명

- **InMemoryRoomQueueTracker** : 아직 생성되지 않은 방에 대한 요청 메타를 보존하고, WebSocket 연결이 성립된 경우에만 실제 DB 반영을 허용함으로써 유령 방 문제를 방지한다.
