# 실시간 채팅 시스템 중복 로그인 제어 설계 문서

이 문서는 실시간 채팅 시스템에서 동일 사용자 ID(userId)가 다중 WebSocket 연결을 시도했을 때 발생하는 세션 충돌 문제를 구조적으로 제어하기 위한 설계를 설명한다. 하나의 브라우저 탭 또는 여러 브라우저에서 동일 userId로 접속할 경우, 이전 세션이 종료되지 않고 유지되면 세션 이중 점유 현상이 발생하며, 이는 메시지 중복 송수신, 사용자 수 불일치, 자원 상태 불일치 등의 문제로 이어진다. 본 문서는 이러한 문제를 방지하기 위해 WebSocket 핸들러 내부의 세션 제어 로직과 Redis 기반의 인증 상태 추적 구조를 연계하여 설계한 구조를 기술한다.

## 문제 정의

동일한 사용자 ID로 복수의 브라우저 또는 탭에서 WebSocket 접속이 발생할 경우, 서버 측에서는 기존 세션이 열린 상태를 유지한 채 새로운 세션을 추가로 허용하게 된다. 이로 인해 단일 사용자에 대해 복수의 세션이 병존하는 구조가 형성되며, 이는 다음과 같은 구조적 문제를 야기한다.

- 동일 사용자에게 동일한 메시지가 중복 송신되는 현상 발생
- 채팅방 내 사용자 수 집계 오류 및 session registry 오염
- permit 기반 동시 접속 통제 구조의 무력화

## 설계 목표

본 구조는 다음과 같은 세 가지 설계 목표를 기반으로 한다.

1. WebSocket 세션 수립 시, 동일 userId의 기존 세션 존재 여부를 구조적으로 감지할 것
2. 기존 세션이 존재하고 열려 있다면 강제 종료하고 사용자에게 통지 메시지를 전송할 것
3. WebSocket 레벨 세션 제어와 Redis 기반의 인증 상태를 연계하여 정합성을 유지할 것

## 구현 구조 및 흐름 설명

WebSocket 연결 수립 시점인 afterConnectionEstablished 메서드에서, session attribute로부터 roomNumber, userName, userId를 추출한 후, 해당 room에 이미 등록된 동일 userName의 세션이 존재하는지 확인한다. 기존 세션이 열려 있을 경우, 명시적인 종료 메시지를 JSON 형식으로 전송한 뒤 정상 상태로 세션을 종료하고, 이후 새로운 세션을 등록하는 방식으로 session registry를 정리한다. 해당 로직은 userId 단위의 연결 고유성을 유지하며, 자원 정합성을 확보하는 구조로 작동한다.

## Redis 기반 인증 상태 연계 구조

WebSocket 수준의 세션 제어는 클라이언트 측에서의 브라우저 탭 중복 연결을 방지할 수 있으나, 서버 측 인증 상태와의 연결이 단절되어 있을 경우 사용자 인증의 위변조 가능성이 존재한다. 이를 방지하기 위해 JWT 기반 인증 구조를 Redis에 연계하여 userId 단위의 토큰 서명 정보를 상태로 보존한다.

Redis에는 다음과 같은 형식의 Hash 구조를 사용한다:

- Key: user:{userId}
- Field:
  - token: JWT Access Token
  - signature: JWT 발급 시 고유 서명 값 또는 검증용 signature key

사용자가 새로운 클라이언트에서 로그인할 경우 Redis 내 기존 signature와 새로운 서명이 불일치할 경우 이를 새로운 브라우저 세션으로 간주하고, 이전에 존재하는 WebSocket 세션을 무효화 처리함으로써 인증 정합성을 유지할 수 있다. 이 구조는 향후 RefreshToken 구조, Redis TTL 관리, 서명 기반 토큰 무효화 전략 등으로 확장 가능하며, 인증-세션 간 연계 기반을 제공한다.

## 구조적 효과 요약

- 동일 userId에 대해 하나의 WebSocket 세션만 유지됨을 보장하며, 세션 레벨 충돌을 방지함
- 인증 상태와 연결 상태 간의 분리를 해소하여 토큰 위변조 또는 비정상 세션 확장을 차단
- 사용자 경험 차원에서 기존 접속 종료를 명시적으로 통지함으로써 혼란 방지
- Redis 기반 인증 연계 구조를 통해 WebSocket 수준의 인증 일관성을 확보함
