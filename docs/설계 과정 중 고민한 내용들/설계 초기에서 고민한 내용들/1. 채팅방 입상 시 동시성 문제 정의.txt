기술 탐구: 멀티스레드 환경에서의 채팅방 입장 동시성 문제 해결 및 확장 가능한 구조 설계

1. 프로젝트 맥락 및 문제 정의
   프로젝트는 다수의 사용자가 실시간으로 소통하는 채팅 서비스를 개발하는 것을 목표로 하며, 
   핵심 동시성 문제는 채팅방의 최대 인원 제한이 존재할 때 복수 사용자가 거의 동시에 특정 방에 
   입장 요청을 보낼 경우 설정된 인원수를 초과하여 입장이 이루어지는 레이스 컨디션(Race Condition)이 
   발생할 가능성이다.
   
   예컨대, 9명이 있는 방에 두 명이 동시에 입장을 시도하면 양쪽 모두 조건 "9명 < 10명"을 통과하여 
   결과적으로 11명이 입장하게 되는 현상이 발생할 수 있다.
   
   이 문제는 Check-Then-Act 패턴의 구조적 한계에서 비롯되며, 확인 시점과 조작 시점 사이의 상태 변경에 
   대응하지 못함에 기인한다. 문제의 기초 원리를 파악하기 위해 OpenCSF Synchronization Overview 등의 
   자료를 기반으로 임계 영역(Critical Section)과 동기화(Synchronization)의 필요성을 사전 학습하였다.

2. 초기 접근 및 한계 분석
   초기 해결 접근은 채팅방 입장 처리 메소드(confirmJoinRoom 등)에 synchronized 키워드를 적용하는 
   방식을 포함하였다. synchronized는 단일 JVM 환경 내에서 해당 블록에 대해 스레드 접근을 직렬화함으로써 
   Race Condition을 방지한다.
   
   그러나 이 방식은 단일 서버에서만 동기화를 보장하므로, 다중 인스턴스로 구성된 분산 환경에서는 
   무효하며 확장성에 본질적 한계를 가진다. 따라서 synchronized는 근본적 해결책이 될 수 없음을 인식하였다.

3. 개선 방안: 확장 가능한 큐 기반 입장 요청 처리 구조 설계
   분산 환경에서도 확장 가능하도록 하기 위해 입장 요청을 비동기 큐 기반 구조로 처리하는 설계를 도입하였다.
   사용자의 입장 요청은 즉시 처리되지 않고 방별 대기열에 등록되며, 실제 입장은 후속 처리기로 이관된다.
   
   RoomJoinService는 사용자의 요청을 수신하고, DB 기반 인원 체크 후 JoinRequestQueueManager에 등록만 수행한다.
   입장 확정은 WebSocket 핸들러 등 외부 트리거에 의해 수행되며, 이는 처리 책임의 분리와 결합도 완화를 유도하며,
   메시지 큐 기반 구조로 확장 가능하다.

4. 적용 기술 및 기술 탐구 내용
   동시성 문제 방지를 위해 java.util.concurrent 패키지의 ConcurrentHashMap과 ConcurrentLinkedQueue를 사용하였다.
   이들 자료구조는 세밀한 락 분할(Fine-grained Locking) 혹은 CAS 기반 원자적 연산을 활용하여 스레드 간 안전한 데이터 접근을 보장한다.
   
   일반 HashMap이나 Collections.synchronizedMap에 비해 성능과 안정성 면에서 우위에 있다. CAS(Compare-And-Swap)는 
   현재 값을 읽은 뒤 기대값과 비교하여 조건부로 갱신하는 방식으로, 실패 시 재시도를 반복하는 구조를 통해 락 없이 원자성을 확보한다.
   
   또한 Memory Visibility 측면에서도 synchronized 블록 종료, volatile, Atomic 연산 등이 변경 사항의 즉시 가시화를 보장함을 학습하였다.
   단일 연산의 원자성은 Concurrent 자료구조로 해결되나, "인원수 체크 후 요청 등록"이라는 복합 연산 자체의 원자성은 보장되지 않기에 
   confirmJoinRoom 내에서는 currentPeople + queueSize >= maxPeople 판단을 동기화된 영역에서 수행하거나 별도 원자적 관리가 필요함을 인지하였다.

5. 구현 내용
   RoomJoinService.java에서는 confirmJoinRoom 메소드에 synchronized 키워드를 적용하거나 이에 준하는 동기화 논리를 도입하였다.
   해당 메소드는 DB로부터 현재 인원수를 조회하고, queueSize를 합산하여 최대 인원 초과 여부를 판단한다.
   
   JoinRequestQueueManager.java에서는 ConcurrentHashMap과 ConcurrentLinkedQueue를 사용하여 enqueueRequest, 
   countValidRequests, purgeExpiredEntries 등의 메소드를 통해 대기열을 관리하며, 각 방별 대기열은 독립적으로 처리되어 
   다중 방 요청에 대한 동시성이 확보된다.

6. 검증 (동시성 테스트)
   ExecutorService를 통해 다수의 스레드를 생성하고, 각 스레드가 동시에 confirmJoinRoom 메소드를 호출하도록 설정하여 
   테스트를 수행하였다.
   
   예컨대 최대 10명 제한의 방에 9명이 있는 상태에서 5명 이상의 스레드가 동시에 입장을 시도하도록 하였다. 
   synchronized 없이 일반 HashMap을 사용할 경우 11명 이상의 입장이 이루어졌으나, 개선된 구조에서는 초과 사용자가 
   대기열에만 등록되고 방에는 입장하지 않는 결과가 확인되었다.
   
   로그와 실행 결과를 통해 Race Condition이 해결되었음을 검증하였다.

7. 학습 내용 및 향후 계획
   본 구현을 통해 멀티스레드 환경의 Race Condition 구조와 그 해결 메커니즘(원자성, 락, 가시성 등)을 실습하였으며, 
   java.util.concurrent 기반의 구조적 안정성과 확장 가능성을 직접 확인하였다.
   
   향후 RabbitMQ, Kafka 등 메시지 큐와의 연계를 통해 완전한 분산 구조로 이관하고, 트랜잭션 기반 동시성 제어(DB Lock, 
   분산 트랜잭션 관리) 및 복합 연산의 원자성 확보 방법에 대한 학습을 이어갈 예정이다.
