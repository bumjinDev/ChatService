■ 1. 설계 목적 및 배경 (구조적 동기 및 개선 필요성 정당화)

기존 실시간 채팅 시스템의 방 입장 흐름은 다음과 같이 이원화된 분산 처리 구조로 설계되어 있었다. 사용자가 채팅방에 입장하려 할 경우, 먼저 Spring MVC Controller를 통해 방 번호를 포함한 입장 요청을 전송하면, 해당 컨트롤러는 Service 계층을 호출하여 해당 방이 존재하는지, 정원이 초과되었는지를 판단한 후 방 페이지를 반환하고, 이후 페이지 내부의 JS 코드가 WebSocket 연결을 수행하는 방식이다. 이 구조는 직관적으로 단순해 보이나, 설계상 다음과 같은 치명적인 결함을 내포하고 있다.

[ 자원 점유와 상태 검증의 분리로 인한 무결성 붕괴 ]
: 실질적인 DB 자원 점유(즉, 방 인원수 증가 또는 신규 방 생성)는 WebSocket의 afterConnectionEstablished() 내부에서 수행된다. 이는 사용자의 최종 접속 의사를 네트워크 계층(WebSocket)이 검증한 이후에 DB 작업을 수행하는 방식인데, 중간 과정인 Spring Controller 계층에서는 오직 입장 가능 여부만 판단할 뿐 실질적인 자원 점유는 발생하지 않는다. 결과적으로, 사용자가 Spring Controller를 통해 입장 가능 판단을 받은 후 WebSocket 연결 과정에서 네트워크 지연, 클라이언트 종료, 브라우저 비정상 동작 등으로 연결이 실패할 경우, 입장 가능 판단만 이루어진 채 자원 점유는 이루어지지 않은 비일관 상태가 발생하게 된다.

[ WebSocket 계층에서의 검증 불가능성 ]
: 위 구조는 Java 기반 Spring MVC Controller와 WebSocket 핸들러 사이에 명확한 컨텍스트 전달 수단이 없기 때문에, JS에서 WebSocket 연결을 수행한 이후 afterConnectionEstablished() 단계에서 사용자가 입장이 가능한지 여부를 다시 판단하는 것이 불가능하다. 다시 말해, Controller에서 반환된 결과와 WebSocket 계층이 공유하는 상태 공간이 없으므로, 사용자가 방에 입장 가능한지 여부를 WebSocket 핸들러가 사전에 알 수 있는 경로가 없다. 그 결과, 이미 인원이 초과된 방에 사용자가 WebSocket을 통해 강제로 연결을 시도하면 IllegalStateException 등의 런타임 예외는 발생하더라도, 이는 클라이언트 단에서는 명확한 피드백 없이 WebSocket이 강제 종료되는 형태로만 나타나며, 이는 UX 및 디버깅 측면 모두에서 심각한 문제를 유발한다.

[ 예외 처리와 피드백 구조의 단절 ]
: Spring Controller 계층은 @ExceptionHandler 또는 @ControllerAdvice를 통해 적절한 HTML 또는 View 기반 응답을 제공할 수 있지만, WebSocket은 기본적으로 상태 코드(예: 4001, 4003 등)와 함께 연결 종료(CloseStatus)만 가능하므로 정제된 피드백 전달 구조가 없다. 결과적으로, 사용자가 어떤 이유로 입장에 실패했는지 알 수 없으며, 입장 실패의 원인을 알 수 없는 블랙박스 구조가 된다.

[ 리소스 낭비 및 정합성 붕괴 방지 필요 ]
: 사용자의 입장 요청이 실제 입장까지 이어지지 않으면, 입장 대기열, Redis 또는 DB상의 캐시, 비동기 큐 등의 자원 할당이 누적되며 리소스 누수 또는 부정확한 상태 동기화가 발생한다. 특히, 방을 새로 생성해야 하는 경우에는 방 메타정보 테이블이 먼저 생성되고 사용자가 연결되지 않음으로써 실제로는 사용되지 않는 유령 방이 DB에 남아 있는 상태가 된다. 이를 정리하기 위해 스케줄러가 존재하더라도, 본질적으로 상태 전이 흐름이 분리되어 있다면 복구는 항상 사후적이며 불완전하다.

위와 같은 근본적인 문제를 제거하기 위해, 본 설계는 방 입장 과정을 두 단계로 분리하되, 흐름상 단절이 없는 논리적 연속선 내에서 재구성하는 것을 목표로 한다. 즉, 1단계(Spring Controller)는 입장 검증 및 예약(대기열 등록)을 수행하고, 2단계(WebSocket)는 예약 확인 후 최종 자원 점유 및 입장을 수행하는 구조로 개선된다. 이를 통해 다음과 같은 정합성과 실무적 이점을 확보한다:

■ 2. [기대 사항]
- 입장 가능 여부와 자원 점유가 비동기지만 동일한 사용자 요청 컨텍스트 내에서 일관되게 처리됨.
예외 발생 시점이 1차 Controller 계층으로 집중되어 @ExceptionHandler 기반의 정제된 피드백 가능.
WebSocket 단에서는 오직 예약된 사용자만 입장을 승인함으로써 보안성과 방어적 로직 강화.
전체 시스템은 RabbitMQ 등 메시지 브로커로 확장 가능하도록 대기열 구조를 미리 추상화함.