기술 내부 구현 원리: synchronized, ConcurrentHashMap, ConcurrentLinkedQueue

본인이 사용한 특정 라이브러리들이 '스레드 안전함' 또는 '동시성을 높임'을 보장하기 위해 내부적으로 어떤 기술(원리)을 사용하는지에 대한 설명입니다.

synchronized 키워드:
원리: synchronized는 자바 객체에 부여된 모니터(Monitor)라는 개념을 사용합니다. 각 객체는 하나의 모니터 락(Monitor Lock)을 가지고 있으며, synchronized 블록 또는 메소드를 실행하려는 스레드는 해당 객체의 모니터 락을 획득해야만 진입할 수 있습니다.
내부 기술 맥락: 이 모니터 락은 운영체제나 JVM 레벨에서 제공하는 뮤텍스(Mutex)와 같은 상호 배제(Mutual Exclusion) 기본 요소에 의해 구현됩니다. 하드웨어의 원자적 명령어(CAS 등)를 기반으로 OS가 제공하는 락 기능을 JVM이 활용하여 synchronized를 구현하는 것입니다.
요약: synchronized는 모니터 락을 사용하여 임계 영역에 대한 스레드 접근을 직렬화(Serialize)합니다. 한 스레드가 락을 획득하면 다른 스레드들은 그 락이 해제될 때까지 대기(Blocking)하게 됩니다.

ConcurrentHashMap:
원리: ConcurrentHashMap은 Hashtable이나 Collections.synchronizedMap처럼 맵 전체에 하나의 락을 걸지 않습니다. 여러 스레드가 동시에 맵에 접근할 때 병목 현상을 최소화하기 위해 기술들을 조합합니다.
내부 기술 맥락 (주요 아이디어):
락 분할(Lock Striking / Segment Locking): (구현 버전에서) 맵을 여러 구역(세그먼트 등)으로 나누고 각 구역마다 별도 락을 가집니다. 스레드는 접근하는 구역의 락만 얻어 다른 스레드가 다른 구역에 동시 접근 가능합니다.
노드 레벨 락킹 및 CAS 활용: (신규 구현에서) 더 세밀하게, 각 노드 단위나 연결 리스트/트리 구조에서 락을 걸거나 CAS 연산(Compare-And-Swap)을 적극 사용합니다. 노드 연결, 사이즈 업데이트 등을 CAS로 원자적으로 수행합니다. 읽기 연산은 대부분 락 없이 가능합니다.
요약: ConcurrentHashMap은 락 분할이나 CAS와 같은 비차단(Non-blocking) 원자적 연산을 활용하여 맵의 개별 연산(put, get 등)에 대한 스레드 안전성을 높이면서도 전체 락 방식보다 동시성을 크게 향상시킵니다.

ConcurrentLinkedQueue:

원리: ConcurrentLinkedQueue는 연결 리스트 구조이며, 락(Lock)을 전혀 사용하지 않는 완전한 락-프리(Lock-Free) 알고리즘으로 구현됩니다.
내부 기술 맥락: 큐의 핵심인 노드(Node) 추가/제거는 CAS 연산을 통해서만 이루어집니다. 노드의 next 포인터나 큐의 head/tail 포인터를 CAS로 원자적으로 업데이트합니다. 성공할 때까지 재시도하는 방식으로 동시성을 확보합니다.
요약: ConcurrentLinkedQueue는 노드 포인터 및 head/tail 포인터에 대한 CAS 연산만을 사용하여 큐의 개별 연산(offer, poll 등)에 대한 스레드 안전성을 보장하며, 스레드들은 서로를 차단하지 않고 경쟁적으로 CAS를 시도하여 작업을 완료합니다.

왜 이러한 '내부 구현 기술의 맥락과 원리'를 아는 것이 중요한가?
정확한 보장 범위 이해: 라이브러리가 '무엇'을 안전하게 해주는지(개별 연산)와 '무엇'은 보장하지 않는지(복합 연산)를 그 기술적 근거(개별 연산만 CAS 등으로 보호)를 통해 명확히 이해합니다.
올바른 문제 해결 적용: Check-Then-Act 같은 복합 문제를 해결할 때, 왜 단순 라이브러리 메소드 호출만으로는 부족하며 어떤 추가 기술(synchronized, Atomic, map.compute, CAS 루프 등)이 왜 필요한지 기술적으로 판단할 수 있습니다.
디버깅 및 성능: 문제 발생 시 원인 파악(어떤 종류의 기술 문제인지)과 성능 병목 지점 추적에 도움이 됩니다.
