[설계 목적 및 배경]
실시간 채팅 시스템에서 사용자 입장 과정을 관리할 때 발생 가능한 동시성 문제, 자원 누수, 상태 정합성 문제 등을 명확히 해결하기 위해 설계가 필요하였다. 입장 과정은 REST API를 통한 사전 자격 부여 단계와 WebSocket 연결을 통한 실제 입장 단계로 명확히 분리되어 있으며, 각 단계는 서로 독립된 상태 기반 분기 구조를 통해 조정된다. 이러한 설계는 시스템 자원의 낭비를 방지하고 예측 가능한 입장 흐름을 보장하기 위한 기반으로 작동하며, 이후 MQ 및 Redis 기반의 외부 상태 동기화 전략으로 확장 가능하도록 준비되어 있다.

[고려한 동기화 전략]
2.1. 세마포어(Semaphore) 방식
세마포어는 프로그래밍적으로 제한된 수의 자원을 제어하는 메커니즘으로, 실시간 채팅 시스템에서는 방별 입장 가능 인원 수를 직접적인 자원으로 간주하여 이를 추상화한다. Java에서는 tryAcquire()를 통해 비블로킹 방식으로 자원 점유를 시도할 수 있으며, 성공 시 입장 허가를 의미한다. 하지만 REST API에서의 사전 검증 이후 실제 입장이 이루어지는 WebSocket 연결까지의 시간차로 인해, 사용자가 입장 요청을 하고도 연결하지 않거나 실패할 경우, 점유된 세마포어 자원이 해제되지 않는 문제가 발생한다. 이로 인해 상태 복구 로직을 반드시 설계해야 하며, 이는 서버 종료, 사용자 이탈, 네트워크 오류 등 다양한 조건을 포괄해야 하므로 복잡도를 가중시킨다.

2.2. 조건 기반 상태 분기 방식
동기화나 자원 점유 없이 입장 가능 여부를 조건 기반으로만 판별한다. 즉, 현재 DB에 기록된 입장 인원 수와 메모리 상 입장 대기 큐에 등록된 사용자 수를 합산하여 최대 허용 인원과 비교하고, 그 결과에 따라 REST API에서 입장 가능 여부를 즉시 결정한다. 이 방식은 세마포어처럼 자원을 명시적으로 선점하지 않기 때문에 자원 누수 문제나 복구 처리가 필요 없다. 또한, 실패 응답을 빠르게 반환할 수 있어 구조적으로 단순하고 복원력을 높인다.

2.3. Redis 기반 상태 추상화 모델
분산 환경을 고려한 설계로서 Redis의 원자적 명령(INCR, DECR)과 Lua 스크립트를 이용하여 상태 점유 및 검증을 하나의 트랜잭션 내에서 수행할 수 있다. 이 모델은 여러 인스턴스 간의 동기화를 보장하며, 세마포어와 유사한 동작을 수행하면서도 분산 캐시로서의 이점을 함께 가진다. Lua 스크립트를 활용할 경우, 조건 분기와 상태 갱신을 동시에 수행할 수 있어 race condition 없이 정확한 입장 제한 처리를 구현할 수 있다.

[세마포어 방식의 구조적 한계 분석]
세마포어는 단일 인스턴스 환경에서의 자원 제어에는 유용하지만, 입장 요청과 실제 입장 사이의 시간차가 존재하는 2단계 구조에서는 상태 정합성을 유지하기 어렵다. 사용자가 입장 요청 후 WebSocket 연결을 실패하거나 지연시키는 경우, 세마포어 자원이 점유된 상태로 방치되므로, 이를 복구하기 위한 별도의 타임아웃 스케줄러를 구현해야 하며, 이는 상태 관리 책임을 단일 컴포넌트에 집중시켜 장애 시 대응 복잡도를 증가시킨다. 특히 서버 인스턴스 장애 또는 사용자 브라우저 비정상 종료와 같은 외부 요인에 대해 정확한 복구를 수행하기 어렵다는 것이 구조적 한계다.

[조건 기반 상태 분기 방식의 채택 근거]
조건 기반 분기 방식은 구조적으로 단순하며, 상태 복구가 필요 없는 점에서 유지보수 비용이 낮고 실패 시 즉시 판단이 가능하다는 장점이 있다. 세마포어 방식과 달리 자원을 사전에 점유하지 않기 때문에 상태 복원 로직이 필요 없으며, REST → WebSocket 흐름 간 시간 비동기성을 구조적으로 흡수할 수 있다. 특히 WebSocket 연결 실패 또는 사용자 이탈에 대해서도 시스템이 상태를 보정할 필요 없이 자연스럽게 방어 동작이 가능하다.

[타임아웃과 RTT 고려]
REST API 요청과 WebSocket 연결 시도 간에는 일정한 RTT(왕복 지연 시간) 차가 존재하며, 이 차이를 기반으로 사용자의 실제 연결 시도를 판별할 수 있어야 한다. 이를 위해 입장 요청 후 일정 시간 내에 WebSocket 연결이 이루어지지 않으면 해당 사용자 엔트리는 큐에서 제거되며, 이는 TTL 기반으로 구현된다. 이와 함께, 연결 시도를 했으나 실패한 사용자와 아예 시도를 하지 않은 사용자를 구분하여 처리하는 방식도 구현되며, 이 구분은 향후 분석 로깅이나 유저 피드백 처리에도 활용 가능하다.

[구현 계획 및 테스트 방향]
초기 구현은 REST Controller와 WebSocket Handler 간의 입장 흐름을 명확히 구분하여 설계하며, 상태 판별을 담당하는 RoomJoinService를 통해 양측 흐름을 중재한다. 각 단계는 상태 추적 객체에 의존하여 조건 분기하며, WebSocket 연결이 수립된 이후에만 세션을 등록하도록 구현한다. 이후 단위 테스트를 통해 예상 시나리오에 따른 상태 일관성 검증을 진행하며, 타임아웃 기반 제거 흐름, 동시 접속 경합 테스트, 비정상 종료 시나리오 등을 포함하여 테스트 계획을 수립한다.

[기술 선택에 따른 구조적 위상 차이 및 실험 기반 확장 계획]
세마포어, 조건 분기, Redis 기반 세 가지 입장 통제 구조를 모두 실험 대상으로 삼아, 실제 TPS(초당 요청 처리량) 조건에서의 안정성과 복구 가능성을 비교 검증한다. 각 방식은 상태 복구 책임의 위치가 다르며, 예외 상황 대응 방식에 있어서도 명확한 차이가 발생한다. 예컨대 Redis Lua 방식은 상태 복구가 필요 없고 외부화되어 있으나 스크립트 복잡도와 관리 포인트가 증가하며, 세마포어는 자원 직접 제어에 적합하나 로컬 상태 유지에 의존하는 단점이 있다. 이 실험 결과는 실제 운영 시 다중 인스턴스 확장 구조 선택 시 주요 판단 근거로 활용된다.

[설계 완성도를 위한 최소 학습 항목 정의]
현재 구조를 설계하고 구현하는 데 필요한 기술 요소는 다음과 같다. Java의 Semaphore와 그 동작 방식, WebSocket 연결 핸드셰이크와 상태 전이 타이밍 이해, Spring Scheduler 기반의 타임아웃 복구 처리, REST ↔ WebSocket 간 상태 연계 흐름 구성 능력, Redis의 INCR/DECR 명령과 Lua 기반 원자성 제어 구현 등이다. 특히 Redis 기반 설계에서는 트랜잭션적 정합성과 실행 속도 분석이 필요하며, 실제 Lua 스크립트로 예외 처리 흐름까지 구축할 수 있어야 한다.

■ 3. 구조 설계 요점
입장 흐름은 명확히 구분된 2단계 큐 기반 구조로 설계된다. 1단계에서는 Spring MVC 컨트롤러가 사용자의 입장 요청을 수신하고, 내부적으로 현재 인원 수 및 대기 큐 상황을 확인한 후 입장 가능 여부를 판정하고 대기열에 등록한다. 이 단계에서는 단지 HTTP 요청만 다루며, 실질적인 세션 수립은 이루어지지 않는다. 2단계에서는 WebSocket 핸들러가 세션 연결 시도 시점을 포착하고, 등록된 대기열 정보를 기준으로 유효성을 검증한 뒤 실제 입장 처리를 수행한다. 이 구조는 입장 요청과 입장 실행을 완전히 분리하여 네트워크 지연, 사용자 실패 등 외부 변수에 의한 오류 전파를 방지한다. 또한 방 생성 요청과 입장 요청은 별개의 흐름으로 분리되며, 생성 대기 상태의 방은 InMemoryRoomQueueTracker가 전담하여 관리한다.

■ 4. 상세 동작 흐름
[1단계 - Spring MVC Controller]에서는 사용자가 특정 방으로 입장을 시도할 때, RoomJoinViewController에서 전달된 roomId와 userId를 기반으로 RoomJoinService.confirmJoin() 메서드가 호출된다. 이 메서드는 해당 방의 현재 인원과 입장 대기 큐에 있는 인원을 합산하여 최대 허용 인원과 비교하고, 조건을 만족할 경우 InMemoryJoinRequestQueue에 해당 userId를 등록한다. 이후 JSP 페이지를 반환하며, 이 JSP는 내부적으로 WebSocket 연결을 수행하는 자바스크립트를 포함한다.

[2단계 - WebSocket Handler]에서는 afterConnectionEstablished() 이벤트가 발생할 때, 세션에서 userId와 roomId를 추출한 후 InMemoryJoinRequestQueue에서 등록 여부를 확인한다. 등록되지 않은 사용자는 위조된 요청으로 간주되어 즉시 연결 종료 처리된다. 등록된 사용자라면 큐에서 해당 엔트리를 제거하고, 이후 RoomJoinService.joinRoom()을 호출하여 실제 입장 처리를 수행한다. 만약 방이 아직 DB에 존재하지 않는다면 InMemoryRoomQueueTracker를 통해 임시 방 생성을 수행하고 DB에 반영한다. 이후 세션을 ChatSessionRegistry에 등록하고 메시지 브로드캐스팅 준비를 완료한다.

■ 5. 자료구조 구성
InMemoryRoomQueueTracker는 아직 DB에 저장되지 않은 방 정보를 roomId 기준으로 추적하며, 이는 생성 요청이 들어온 시점에서만 초기화된다. InMemoryJoinRequestQueue는 각 roomId에 대해 ConcurrentLinkedQueue 형태의 대기열을 가지며, 각 queue는 userId의 순서를 보장하는 FIFO 구조로 유지된다. 이 두 자료구조는 입장 검증과 방 생성 검증을 분리하여 담당하며, 이후 Redis 혹은 MQ 기반 구조로 치환될 수 있도록 DI 기반으로 설계되어 있다.

■ 6. 예외 처리 및 보안
입장 대기 큐에 등록되지 않은 사용자가 WebSocket으로 직접 접속 시도할 경우, 이는 정상적인 절차를 위반한 것으로 간주되어 핸들러에서 즉시 세션을 종료한다. REST API 단계에서 인원 초과로 인해 입장이 거부된 경우, ExceptionHandler를 통해 사용자에게 명확한 안내 메시지를 포함한 JSP 페이지를 반환한다. 동일 사용자에 의한 중복 로그인 시에는 기존 세션을 종료하고 새로운 세션을 허용하는 로직이 유지되며, Redis 또는 메모리 기반 세션 레지스트리를 통해 세션 추적이 수행된다.

■ 7. 확장성 계획
현재 구조는 단일 인스턴스 기준으로 설계되어 있으나, 향후 Redis 기반 상태 저장소 및 RabbitMQ 기반의 비동기 큐를 도입하여 멀티 인스턴스 환경에서도 상태 정합성과 요청 순서를 유지할 수 있도록 확장 계획이 수립되어 있다. 이때 InMemoryJoinRequestQueue와 InMemoryRoomQueueTracker는 각각 Redis Sorted Set 및 MQ 큐로 대체될 수 있으며, 트랜잭션 처리를 위한 Lua 스크립트와 TTL 정책이 함께 사용될 예정이다. 현 설계는 이러한 구조적 확장을 염두에 둔 테스트용 프로토타입으로 정의된다.

