[시행착오 정리] 실행 구조 이해의 벽과 설계적 정당화

────────────────────────────────────────────

1. 문제 인식의 시작점
────────────────────────────────────────────
- 프로젝트 목적은 단순한 채팅 입장 기능 구현이었으나, 입장 시점에서의 상태 정합성과 비동기 환경에서의 동시성 문제가 본질적으로 제기됨.
- WebSocket 연결 직전에 사용자의 입장 유효성을 판단하고, 동시에 여러 사용자 요청이 들어오는 상황을 시뮬레이션하면서 shared resource 경합을 인지함.
- ConcurrentHashMap과 ConcurrentLinkedQueue를 통해 thread-safe한 상태 관리 구조를 설계했으나, 연산 조합 구간에서 race condition의 발생 가능성을 발견함.
- "Concurrent 자료구조라면 괜찮겠지"라는 추정이 실제로는 불완전하다는 점을 체감함.

2. 개념적 체계화 시도
────────────────────────────────────────────
- 임계 구역(Critical Section): 특정 연산 구간에서 여러 스레드가 동시에 접근하면 정합성 오류가 발생할 수 있는 지점.
- 상호 배제(Mutex): 위 임계 구역에 대해 하나의 스레드만 접근 가능하게 제한하는 논리적/물리적 조치. Java에서는 synchronized, ReentrantLock 등으로 구현.
- 락의 범위와 빈도에 따른 비용:
    · 지나치게 세분화된 락은 매 호출마다 context switch를 유발하여 CPU 낭비 발생.
    · 반대로 락 범위가 과도하게 넓으면 다른 스레드가 장시간 대기하면서 병목 유발.
- Concurrent 자료구조는 개별 연산에 대해 atomic 보장을 제공하지만,
  연산 조합(ex: get → condition check → put)에는 별도의 상호 배제가 필요함.

3. 스레드 실행 주체와 흐름에 대한 구조적 이해
────────────────────────────────────────────
- 톰캣은 Java Servlet Container로서, 내부적으로 Executor 기반의 스레드 풀을 구성함.
- HTTP 요청이 들어오면 Acceptor 스레드가 이를 수신하고, 워커 스레드에게 전달하여 처리.
- 각 요청은 하나의 워커 스레드에 의해 처리되며, 이는 DispatcherServlet → Controller → Service → Repository → DAO 구조로 이어지는 call stack에서 동작.
- 즉, RoomJoinService.confirmJoinRoom()은 특정 워커 스레드 하나에 바인딩된 메서드 실행 흐름의 일부이며,
  여러 요청은 서로 다른 스레드에서 동시에 처리될 수 있음.
- 클래스는 JVM Method Area에 로드되어 있으며, 이 클래스의 메서드는 해당 스레드의 Stack Frame에 올라 실행됨.
  바이트코드는 필요 시 JIT 컴파일되어 네이티브 코드로 실행됨.

4. 실전 구조에 대한 설계 관찰
────────────────────────────────────────────
- JoinRequestQueueManager는 싱글톤 Spring Bean으로 관리되며, 여러 요청이 동시에 접근할 수 있는 구조.
- 내부 필드는 ConcurrentHashMap<Integer, Queue>이며, 각 Queue는 ConcurrentLinkedQueue로 구현됨.
- 그러나 'queue.get → queue.add/poll → queue.filter' 등의 연산은 복합적이며, 순차적 실행 보장이 없을 경우 race condition 유발 가능성이 존재함.
- 이에 따라 roomNumber 단위로 ReentrantLock을 분기 적용하는 방식이 필요함:
    · queueLocks: Map<Integer, ReentrantLock> 형태로 유지
    · enqueueRequest, purgeExpiredEntries, hasValidRequest 등에 해당 락 적용
    · 메서드 전체가 아닌, 각 roomNumber 단위의 critical section에 한정하여 lock 범위 최소화
- 전역 락 또는 클래스 레벨의 synchronized 사용은 요청 전체에 대해 병렬성 차단을 유발하므로 설계상 부적절함.

5. 학습 경계의 자각
────────────────────────────────────────────
- JVM 내부 구조, Method Area, Thread Stack, JIT 등은 이론적으로 학습 가능하나,
  포트폴리오 목표는 동시성 제어를 통한 구조적 안정성 확보임.
- 따라서 "톰캣의 스레드가 실제로 어느 구조까지 관여하는가"를 넘어,
  "내 코드의 어떤 영역이 경쟁 구간이 되는가"를 판단하는 것이 우선.
- 구조적 문제를 인식하고 그에 대한 제어(뮤텍스 설계, 상태 분리)를 설계해내는 것이 현 시점에서 가장 효율적인 학습 방법임.

6. 결론 및 향후 방향
────────────────────────────────────────────
- 지금까지 정리한 수준(상호 배제 구조 식별, 락 분리 조건 분석, 톰캣 실행 흐름 이해)은
- 이후 복귀 시에는 다음 순서로 단계적 복습을 수행할 것:
    1. roomNumber 단위 락 분리 로직 정착
    2. TTL 만료 및 purge 조건 분기 정리
    3. WebSocket 입장 시점과 상태 큐 연결 방식 재정리

────────────────────────────────────────────
(끝)
