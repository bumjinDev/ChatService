📘 [SemaphoreRegistry 설계 보강 및 구조적 결함 분석 메모]

============================================================

🔍 목적
현재 SemaphoreRegistry 클래스는 방 번호별 동시 입장 제어를 위해 설계되었지만,
구조적 완성도, 제어 능력, 확장성 측면에서 다음과 같은 중대한 한계점을 포함하고 있다.
이 문서는 그 결함을 기술적 기준으로 식별하고, 설계 보강 기준을 제시한다.

============================================================

1. 상태 일관성 추적 기능이 결정적으로 생략되었다

- 현재 구조는 register(), unregister(), tryAcquire(), release()만 제공되며,
  현재 permit 상태, 잔여 인원, 총 등록 방 수 등 시스템 전역 상태 추적 API가 존재하지 않는다.
- 시스템 운영 시 디버깅, 모니터링, 관리자 UI 등에서 사용 불가.
- 추후 TTL 기반 스케줄러 연동이나 dead room 식별 시 확장 불가.

🔧 보강 필요:
- getAvailablePermits(roomId)
- getTotalRegisteredRooms()
- isFull(roomId)

============================================================

2. 동시성 누수 상황에 대한 복구 구조 없음

- tryAcquire() 성공 이후 예외로 입장이 중단될 경우 release()가 호출되지 않을 수 있음
- release()가 중복 호출될 경우 permit 오용 상태 발생

🔧 보강 필요:
- release() 호출 전에 현재 점유 상태 확인 또는 usage 로깅
- 입장 시점에서 entryContext 등 context 보존 후 복구 흐름 적용

============================================================

3. 비원자적 조합 연산 흐름이 고려되지 않음

- exists() → tryAcquire(), exists() → release() 흐름에서
  중간에 다른 스레드에 의해 unregister() 될 수 있음 → TOCTOU 취약점

🔧 보강 필요:
- 모든 연산은 get() → null 검사 → 동작 수행을 하나의 메서드 내 원자적 흐름으로 작성

============================================================

4. 자원 누수에 대한 정리 정책 부재

- unregister()는 수동 호출에 의존
- 방이 종료된 이후에도 세마포어가 남아 있을 경우 메모리 누수

🔧 보강 필요:
- TTL 설정 후 마지막 permit 사용 시점 기록
- 주기적 clean-up 스케줄러와 연동

============================================================

5. 클래스 책임이 '통제자'가 아닌 단순 '위임자' 수준에 머무름

- 현재는 Map을 통해 put/get 후 Semaphore의 메서드를 위임 호출만 함
- 내부적으로 정책, 조건, 상태 판단 흐름이 전무 → 의미 있는 제어 구조 부재

🔧 보강 필요:
- 자원 점유 정책 조건 삽입
- 세마포어 외부 노출 없이 내부적으로 제어 흐름 캡슐화

============================================================

📌 종합 진단

현재 SemaphoreRegistry는 기능적으로는 작동하나, 구조적으로는 통제 계층이 아닌 단순 위임 계층에 머무르고 있음.
설계 문서에서 선언된 '자원 제어자'라는 위상을 실현하기 위해선,
- 상태 질의 계층
- 비정상 흐름 복구 구조
- 자동 자원 해제 정책
- 원자적 동작 시퀀스 구조

이 네 가지의 보강이 필수적이다.